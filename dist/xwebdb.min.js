!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).xwebdb={})}(this,(function(e){"use strict";const t=[];for(let e=0;e<256;e++)t[e]=(e<16?"0":"")+e.toString(16);function r(){let e=4294967295*Math.random()|0,r=4294967295*Math.random()|0,n=4294967295*Math.random()|0,s=4294967295*Math.random()|0;return t[255&e]+t[e>>8&255]+t[e>>16&255]+t[e>>24&255]+"-"+t[255&r]+t[r>>8&255]+"-"+t[r>>16&15|64]+t[r>>24&255]+"-"+t[63&n|128]+t[n>>8&255]+"-"+t[n>>16&255]+t[n>>24&255]+t[255&s]+t[s>>8&255]+t[s>>16&255]+t[s>>24&255]}function n(e){for(var t=e.length,r=-1,n=0;n<t;++n)r=(r<<5)+r+e.charCodeAt(n)&4294967295;return r>>>0}var s=Object.freeze({__proto__:null,uid:r,dHash:n});function i(e,t=!1){return JSON.stringify(e,(function(e,r){if(t||a(e,r),void 0!==r)return null===r?null:"function"==typeof this[e].getTime?{$$date:this[e].getTime()}:r}))}function o(e){return JSON.parse(e,(function(e,t){if("$$date"===e)return new Date(t);let r=typeof t;return"string"===r||"number"===r||"boolean"===r||null===t?t:t&&t.$$date?t.$$date:t}))}function a(e,t){if("number"==typeof e&&(e=e.toString()),!("$"!==e[0]||"$$date"===e&&"number"==typeof t||"$$deleted"===e&&!0===t||"$$indexCreated"===e||"$$indexRemoved"===e))throw new Error("XWebDB: Field names cannot begin with the $ character");if(-1!==e.indexOf("."))throw new Error("XWebDB: Field names cannot contain a .")}function h(e){if(Array.isArray(e))e.forEach((e=>h(e)));else if(c(e)&&!(e instanceof Date))for(const[t,r]of Object.entries(e))a(t,r),h(r)}function l(e){return!c(e)}function c(e){return!("object"!=typeof e||null===e||e instanceof Date||Array.isArray(e))}function d(e,t,r=!1){let n=typeof e;if("boolean"===n||"number"===n||"string"===n)return e;if(null===e||e instanceof Date)return e;if(Array.isArray(e))return e.map((e=>d(e,t,r)));if("object"==typeof e){let n={};for(const[s,i]of Object.entries(e))(!r||"$"!==s[0]&&-1===s.indexOf("."))&&(n[s]=d(i,t,r));return n.hasOwnProperty("_id")?t.new(n):n}return JSON.parse(JSON.stringify({temp:e})).temp}function u(e,t){const r="string"==typeof t?t.split("."):t;if(e){if(0===r.length)return e;if(1===r.length)return e[r[0]];if(Array.isArray(e[r[0]])){let t=parseInt(r[1],10);if("number"==typeof t&&!isNaN(t))return u(e[r[0]][t],r.slice(2));let n=new Array;for(let t=0;t<e[r[0]].length;t+=1)n.push(u(e[r[0]][t],r.slice(1)));return n}return u(e[r[0]],r.slice(1))}}function f(e){const t={};!function e(r,n=""){for(const s in r)if(r.hasOwnProperty(s)){const i=n?`${n}.${s}`:s,o=r[s];!Array.isArray(o)&&"object"==typeof o&&null!==o&&Object.keys(o).length&&-1===Object.keys(o).join("").indexOf("$")?e(o,i):t[i]=o}}(e.$deep);const r=Object.assign(e,t);return delete r.$deep,r}function p(e,t){let r=typeof e,n=typeof t;return null===e||"string"===r||"boolean"===r||"number"===r||null===t||"string"===n||"boolean"===n||"number"===n?e===t:e instanceof Date||t instanceof Date?e instanceof Date&&t instanceof Date&&e.getTime()===t.getTime():!(!(Array.isArray(e)&&Array.isArray(t)||!Array.isArray(e)&&!Array.isArray(t))||void 0===e||void 0===t)&&i({temp:e},!0)===i({temp:t},!0)}function y(e,t){let r=typeof e,n=typeof t;return("string"===r||"number"===r||"string"===n||"number"===n||e instanceof Date||t instanceof Date)&&r===n}function w(e,t){return e<t?-1:e>t?1:0}function g(e,t){if(void 0===e)return void 0===t?0:-1;if(void 0===t)return 1;if(null===e)return null===t?0:-1;if(null===t)return 1;let r=typeof e,n=typeof t;if("number"===r)return"number"==typeof t?w(e,t):-1;if("number"===n)return 1;if("string"===r)return"string"===n?w(e,t):-1;if("string"===n)return 1;if("boolean"===r)return"boolean"===n?w(e,t):-1;if("boolean"===n)return 1;if(e instanceof Date)return t instanceof Date?w(e.getTime(),t.getTime()):-1;if(t instanceof Date)return 1;if(Array.isArray(e))return Array.isArray(t)?function(e,t){for(let r=0;r<Math.min(e.length,t.length);r+=1){let n=g(e[r],t[r]);if(0!==n)return n}return w(e.length,t.length)}(e,t):-1;if(Array.isArray(t))return 1;let s=Object.keys(e).sort(),i=Object.keys(t).sort();for(let r=0;r<Math.min(s.length,i.length);r+=1){let n=g(e[s[r]],t[i[r]]);if(0!==n)return n}return w(s.length,i.length)}const m={$size:function(e,t){if(!Array.isArray(e))return!1;if("number"!=typeof t||t%1!=0)throw new Error("XWebDB: $size operator called without an integer");return e.length===t},$elemMatch:function(e,t){if(!Array.isArray(e))return!1;let r=e.length;for(;r--;)if(_(e[r],t))return!0;return!1},$all:function(e,t){if(!Array.isArray(e))throw new Error("XWebDB: $all must be applied on fields of type array");if(!Array.isArray(t))throw new Error("XWebDB: $all must be supplied with argument of type array");for(let r=0;r<t.length;r++)if(-1===e.indexOf(t[r]))return!1;return!0}},b={$type:function(e,t){return["number","boolean","string","undefined"].indexOf(t)>-1?typeof e===t:"array"===t?Array.isArray(e):"null"===t?null===e:"date"===t?e instanceof Date:"object"===t&&!("object"!=typeof e||e instanceof Date||null===e||Array.isArray(e))},$not:(e,t)=>!_({k:e},{k:t}),$eq:(e,t)=>p(e,t),$lt:(e,t)=>y(e,t)&&e<t,$lte:(e,t)=>y(e,t)&&e<=t,$gt:(e,t)=>y(e,t)&&e>t,$gte:(e,t)=>y(e,t)&&e>=t,$mod:function(e,t){if(!Array.isArray(t))throw new Error("XWebDB: malformed mod, must be supplied with an array");if(2!==t.length)throw new Error("XWebDB: malformed mod, array length must be exactly two, a divisor and a remainder");return e%t[0]===t[1]},$ne:function(e,t){return void 0===e||!p(e,t)},$in:function(e,t){if(!Array.isArray(t))throw new Error("XWebDB: $in operator called with a non-array");for(let r=0;r<t.length;r+=1)if(p(e,t[r]))return!0;return!1},$nin:function(e,t){if(!Array.isArray(t))throw new Error("XWebDB: $nin operator called with a non-array");return!b.$in(e,t)},$regex:function(e,t){if(!(t instanceof RegExp))throw new Error("XWebDB: $regex operator called with non regular expression");return"string"==typeof e&&t.test(e)},$exists:function(e,t){return t=!(!t&&""!==t),void 0===e?!t:t},...m};function $(e,t,r){if(!Array.isArray(r))throw new Error("XWebDB: $or/$nor/$and operators should be used with an array");for(let n=0;n<r.length;n+=1){if(_(t,r[n])){if("$or"===e)return!0;if("$nor"===e)return!1}else if("$and"===e)return!1}return"$or"!==e}const v={$and:(e,t)=>$("$and",e,t),$nor:(e,t)=>$("$nor",e,t),$or:(e,t)=>$("$or",e,t),$where:(e,t)=>{if("function"!=typeof t)throw new Error("XWebDB: $where operator used without a function");let r=t.call(e);if("boolean"!=typeof r)throw new Error("XWebDB: $where function must return boolean");return r}};function _(e,t){let r=!1,n=Object.keys(t);for(let e=0;e<n.length;e++){const t=n[e];if(b[t]){r=!0;break}}if(l(e)||l(t)||r)return D({TMP:e},"TMP",t);for(let r=0;r<n.length;r+=1){let s=n[r],i=t[s];if("$"===s[0]){let t=v[s];if(!t)throw new Error("XWebDB: Unknown logical operator "+s);if(!t(e,i))return!1}else if(!D(e,s,i))return!1}return!0}function D(e,t,r,n){const s=u(e,t);if(Array.isArray(s)&&!n){if(Array.isArray(r))return D(e,t,r,!0);if(null!==r&&"object"==typeof r&&!(r instanceof RegExp)){let n=Object.keys(r);for(let s=0;s<n.length;s+=1)if(m[n[s]])return D(e,t,r,!0)}if(r.$ne&&-1!==s.indexOf(r.$ne))return!1;if(Array.isArray(r.$nin)&&r.$nin.filter((e=>-1!==s.indexOf(e))).length)return!1;for(let e=0;e<s.length;e+=1)if(D({TMP:s[e]},"TMP",r))return!0;return!1}if(!("object"!=typeof r||null===r||r instanceof RegExp||Array.isArray(r))){let e=Object.keys(r),t=e.map((e=>e[0])),n=t.filter((e=>"$"===e));if(0!==n.length&&n.length!==t.length)throw new Error("XWebDB: You cannot mix operators and normal fields");if(n.length>0){for(let t=0;t<e.length;t+=1){if(!b[e[t]])throw new Error("XWebDB: Unknown comparison function "+e[t]);if(!b[e[t]](s,r[e[t]]))return!1}return!0}}return r instanceof RegExp?b.$regex(s,r):!!p(s,r)}const x={$set:function(e,t,r){e&&(e[t]=r)},$mul:function(e,t,r){let n=e[t];if("number"!=typeof r||"number"!=typeof n)throw new Error("XWebDB: Multiply operator works only on numbers");e[t]=n*r},$unset:function(e,t){Array.isArray(e)?e.splice(Number(t),1):delete e[t]},$push:function(e,t,r){if(e.hasOwnProperty(t)||(e[t]=[]),!Array.isArray(e[t]))throw new Error("XWebDB: Can't $push an element on non-array values");if(null!==r&&"object"==typeof r&&r.$slice&&void 0===r.$each&&(r.$each=[]),null!==r&&"object"==typeof r&&r.$each){const n=r.$each,s=r.$slice,i=r.$position,o=r.$sort,a=Object.keys(r);if(a.length>1&&a.filter((e=>-1===["$each","$slice","$position","$sort"].indexOf(e))).length)throw new Error("XWebDB: Can only use the known modifiers $slice, $position and $sort in conjunction with $each when $push to array");if(!Array.isArray(n))throw new Error("XWebDB: $each requires an array value");if(void 0!==s&&"number"!=typeof s)throw new Error("XWebDB: $slice requires a number value");if(i)for(let r=0;r<n.length;r++)e[t].splice(i+r,0,n[r]);else n.forEach((r=>e[t].push(r)));if(o&&("number"==typeof o?1===o?e[t].sort(((e,t)=>g(e,t))):e[t].sort(((e,t)=>g(t,e))):e[t].sort(((e,t)=>{const r=Object.keys(o);for(let n=0;n<r.length;n++){const s=r[n];if(1===o[s]){const r=g(e[s],t[s]);if(r)return r}else{const r=g(t[s],e[s]);if(r)return r}}return 0}))),0===s)e[t]=[];else if("number"==typeof s){let r=0,n=0,i=e[t].length;s<0?(r=Math.max(0,i+s),n=i):s>0&&(r=0,n=Math.min(i,s)),e[t]=e[t].slice(r,n)}}else e[t].push(r)},$addToSet:function(e,t,r){if(e.hasOwnProperty(t)||(e[t]=[]),!Array.isArray(e[t]))throw new Error("XWebDB: Can't $addToSet an element on non-array values");const n=r?r.$each:void 0;if(null!==r&&"object"==typeof r&&n){if(Object.keys(r).length>1)throw new Error("XWebDB: Can't use another field in conjunction with $each on $addToSet modifier");if(!Array.isArray(n))throw new Error("XWebDB: $each requires an array value");n.forEach((r=>x.$addToSet(e,t,r)))}else{let n=!0;for(let s=0;s<e[t].length;s++){if(0===g(e[t][s],r)){n=!1;break}}n&&e[t].push(r)}},$pop:function(e,t,r){if(!Array.isArray(e[t]))throw new Error("XWebDB: Can't $pop an element from non-array values");if("number"!=typeof r||r%1!=0)throw new Error("XWebDB: "+r+" isn't an integer, can't use it with $pop");0!==r&&(e[t]=r>0?e[t].slice(0,e[t].length-1):e[t].slice(1))},$pull:function(e,t,r){if(!Array.isArray(e[t]))throw new Error("XWebDB: Can't $pull an element from non-array values");let n=e[t];for(let e=n.length-1;e>=0;e-=1)_(n[e],r)&&n.splice(e,1)},$pullAll:function(e,t,r){if(!Array.isArray(e[t]))throw new Error("XWebDB: Can't $pull an element from non-array values");let n=e[t];for(let e=n.length-1;e>=0;e-=1)for(let t=0;t<r.length;t++)_(n[e],r[t])&&n.splice(e,1)},$inc:function(e,t,r){if("number"!=typeof r)throw new Error("XWebDB: "+r+" must be a number");if("number"!=typeof e[t]){if(e.hasOwnProperty(t))throw new Error("XWebDB: Can't use the $inc modifier on non-number fields");e[t]=r}else e[t]=e[t]+r},$max:function(e,t,r){(void 0===e[t]||r>e[t])&&(e[t]=r)},$min:function(e,t,r){(void 0===e[t]||r<e[t])&&(e[t]=r)},$currentDate:function(e,t,r){if(!0===r)e[t]=new Date;else if(r.$type&&"timestamp"===r.$type)e[t]=Date.now();else{if(!r.$type||"date"!==r.$type)throw new Error("XWebDB: Malformed $currentDate update query");e[t]=new Date}},$rename:function(e,t,r){if(Array.isArray(e)){let n=Number(r),s=Number(t);e.splice(n,0,e.splice(s,1)[0])}else e[r]=e[t],delete e[t]},$setOnInsert:function(){}},A={},k=Object.keys(x);for(let e=0;e<k.length;e++){const t=k[e];A[t]=(e,r,n)=>{var s="string"==typeof r?r.split("."):r;if(1===s.length)x[t](e,r,n);else{if(void 0===e[s[0]]){if("$unset"===t)return;e[s[0]]={}}let r=s.slice(1).join(".");A[t](e[s[0]],r,n)}}}function O(e,t,r){const n=Object.keys(t),s=n.map((e=>e.charAt(0))),i=s.filter((e=>"$"===e));if(-1!==n.indexOf("_id")&&t._id!==e._id)throw new Error("XWebDB: You cannot change a document's _id");if(0!==i.length&&i.length!==s.length)throw new Error("XWebDB: You cannot mix modifiers and normal fields");let o;if(0===i.length)o=d(t,r),o._id=e._id;else{const s=Array.from(new Set(n));o=d(e,r);for(let e=0;e<s.length;e++){const r=s[e],n=t[r];if(!A[r])throw new Error("XWebDB: Unknown modifier "+r);if("object"!=typeof n)throw new Error("XWebDB: Modifier "+r+"'s query must be an object");const i=Object.keys(n);for(let e=0;e<i.length;e++){const t=i[e];A[r](o,t,n[t])}}}if(h(o),e._id!==o._id)throw new Error("XWebDB: You cannot change a document's _id");return o}var E=Object.freeze({__proto__:null,toDotNotation:f,serialize:i,deserialize:o,clone:d,validateObject:h,isPrimitiveType:l,modify:O,fromDotNotation:u,match:_,compare:g,modifiersKeys:k,equal:p});class j{constructor(e,t){this.db=e,this._query=t||{}}limit(e){return this._limit=e,this}skip(e){return this._skip=e,this}sort(e){return this._sort=e,this}projection(e){return this._projection=e,this}_project(e){if(void 0===this._projection||0===Object.keys(this._projection).length)return e;let t=[],r=0!==this._projection._id;delete this._projection._id;let n=Object.keys(this._projection),s=n.map((e=>this._projection[e])).sort();if(s[0]!==s[s.length-1])throw new Error("XWebDB: Can't both keep and omit fields except for _id");let i=1===s[0];for(let s=0;s<e.length;s++){const o=e[s];let a={};i?(a={$set:{}},n.forEach((e=>{a.$set[e]=u(o,e),void 0===a.$set[e]&&delete a.$set[e]})),a=O({},a,this.db.model)):(a={$unset:{}},n.forEach((e=>{a.$unset[e]=!0})),a=O(o,a,this.db.model)),r?a._id=o._id:delete a._id,t.push(a)}return t}__exec_unsafe(){let e=[];const t=this.db.getCandidates(this._query);for(let r=0;r<t.length;r++)_(t[r],this._query)&&e.push(t[r]);if(this._sort&&e.sort(((e,t)=>{for(const[r,n]of Object.entries(this._sort||{})){let s=n*g(u(e,r),u(t,r));if(0!==s)return s}return 0})),this._limit||this._skip){const t=this._limit||e.length,r=this._skip||0;e=e.slice(r,r+t)}return this._projection&&(e=this._project(e)),e}exec(){const e=this.__exec_unsafe(),t=[];for(let r=0;r<e.length;r++)t.push(d(e[r],this.db.model));return t}}function B(e){let t=typeof e;return"number"===t||"string"===t||"bigint"===t?e:JSON.stringify([[[e]]])}class N{constructor({fieldName:e,unique:t,c:r}){this.keys=[],this.documents=new Map,this.unique=!1,this.fieldName=e,this.comparator=r,this.unique=t}has(e){return this.documents.has(B(e))}insert(e,t){e=B(e);let r=this.documents.get(e);if(r&&this.unique){const t=new Error(`XWebDB: Can't insert key ${e}, it violates the unique constraint`);throw t.key=e,t.prop=this.fieldName,t.errorType="uniqueViolated",t}const n=this.findInsertionIndex(e);this.keys[n]!==e&&this.keys.splice(n,0,e),r||(r=[],this.documents.set(e,r)),r.push(t)}get(e){return Array.isArray(e)?e.map((e=>this.get(B(e)))).flat(1):this.documents.get(B(e))||[]}delete(e,t){e=B(e);const r=this.binarySearch(e);if(-1===r)return!1;const n=this.documents.get(e)||[];return n.splice(n.indexOf(t),1),0===n.length&&(this.keys.splice(r,1),this.documents.delete(e)),!0}findInsertionIndex(e){e=B(e);let t=0,r=this.keys.length;for(;t<r;){const n=Math.floor((t+r)/2);-1===this.comparator(this.keys[n],e)?t=n+1:r=n}return t}binarySearch(e){e=B(e);let t=0,r=this.keys.length-1;for(;t<=r;){const n=Math.floor((t+r)/2);if(0===this.comparator(this.keys[n],e))return n;-1===this.comparator(this.keys[n],e)?t=n+1:r=n-1}return-1}$in(e){e=e.map((e=>B(e)));let t=[];for(let r=0;r<e.length;r++){let n=B(e[r]);t=t.concat(this.get(n))}return t.filter(((e,r)=>t.indexOf(e)===r))}$nin(e){e=e.map((e=>B(e)));let t=[];for(let r=0;r<this.keys.length;r++){let n=B(this.keys[r]);e.includes(n)||(t=t.concat(this.get(n)))}return t}$ne(e){e=B(e);let t=[];for(let r=0;r<this.keys.length;r++){const n=B(this.keys[r]);0!==this.comparator(e,n)&&(t=t.concat(this.get(n)))}return t}betweenBounds(e,t,r,n){let s=0,i=this.keys.length-1,o=[];for(;s<=i;){let a=Math.floor((s+i)/2),h=this.keys[a];if(h<e||!t&&h===e)s=a+1;else{if(!(h>r||!n&&h===r)){o.push(a);for(let r=a-1;r>=s;r--){let n=this.keys[r];if(n<e||!t&&n===e)break;o.push(r)}for(let e=a+1;e<=i;e++){let t=this.keys[e];if(t>r||!n&&t===r)break;o.push(e)}break}i=a-1}}o.sort(((e,t)=>e===t?0:e>t?1:-1));let a=[];for(let e=0;e<o.length;e++){const t=o[e];a=a.concat(this.get(this.keys[t]))}return a}boundedQuery(e){return this.betweenBounds(e.$gt||e.$gte,!!e.$gte,e.$lt||e.$lte,!!e.$lte)}get all(){return Array.from(this.documents.values()).flat()}get numberOfKeys(){return this.keys.length}get size(){return this.all.length}}function W(e){return Array.from(new Set(e.map((e=>{return null===(t=e)?"$NU":"string"==typeof t?"$ST"+t:"boolean"==typeof t?"$BO"+t:"number"==typeof t?"$NO"+t:t instanceof Date?"$DA"+t.getTime():t;var t})))).map((e=>"string"==typeof e?e.substr(3):e))}class I{constructor({fieldName:e,unique:t,sparse:r}){this.unique=!1,this.sparse=!1,this.fieldName=e,t&&(this.unique=t),r&&(this.sparse=r),this.dict=new N({unique:this.unique,c:g,fieldName:this.fieldName})}reset(){this.dict=new N({unique:this.unique,c:g,fieldName:this.fieldName})}insert(e){if(Array.isArray(e))return void this.insertMultipleDocs(e);let t=u(e,this.fieldName);if(void 0!==t||!this.sparse)if(Array.isArray(t)){let r,n=W(t),s=-1;for(let t=0;t<n.length;t++)try{this.dict.insert(n[t],e)}catch(e){r=e,s=t;break}if(r){for(let t=0;t<s;t++)this.dict.delete(n[t],e);throw r}}else this.dict.insert(t,e)}insertMultipleDocs(e){let t,r=-1;for(let n=0;n<e.length;n++)try{this.insert(e[n])}catch(e){t=e,r=n;break}if(t){for(let t=0;t<r;t++)this.remove(e[t]);throw t}}remove(e){if(Array.isArray(e))return void e.forEach((e=>this.remove(e)));let t=u(e,this.fieldName);void 0===t&&this.sparse||(Array.isArray(t)?W(t).forEach((t=>this.dict.delete(t,e))):this.dict.delete(t,e))}update(e,t){if(Array.isArray(e))this.updateMultipleDocs(e);else if(t){this.remove(e);try{this.insert(t)}catch(t){throw this.insert(e),t}}}updateMultipleDocs(e){let t,r=-1;for(let t=0;t<e.length;t++)this.remove(e[t].oldDoc);for(let n=0;n<e.length;n++)try{this.insert(e[n].newDoc)}catch(e){t=e,r=n;break}if(t){for(let t=0;t<r;t++)this.remove(e[t].newDoc);for(let t=0;t<e.length;t++)this.insert(e[t].oldDoc);throw t}}revertUpdate(e,t){var r=[];!Array.isArray(e)&&t?this.update(t,e):Array.isArray(e)&&(e.forEach((e=>{r.push({oldDoc:e.newDoc,newDoc:e.oldDoc})})),this.update(r))}}class S{static new(e){const t=new this;if("object"!=typeof e||null===e)return t;const r=Object.keys({...t,...e});for(let n=0;n<r.length;n++){const s=r[n];let i=t[s],o=e[s];i&&i._$SHOULD_MAP$_?void 0===o?t[s]=i.def:Array.isArray(o)?t[s]=o.map((e=>i.ctr.new(e))):t[s]=i.ctr.new(o):t[s]=void 0===o?i:o}return t}_stripDefaults(){this.constructor._$def||(this.constructor._$def=this.constructor.new({}));let e=this.constructor._$def;const t={};for(const[r,n]of Object.entries(this)){const s=e[r];Array.isArray(n)&&n[0]&&n[0]._stripDefaults?(t[r]=n.map((e=>e._stripDefaults())),0===t[r].length&&delete t[r]):"object"==typeof n&&null!==n&&n._stripDefaults?(t[r]=n._stripDefaults(),0===Object.keys(t[r]).length&&delete t[r]):JSON.stringify(s)!==JSON.stringify(n)&&(t[r]=n)}return t}}class X extends S{constructor(){super(...arguments),this._id=r()}}class C{constructor(e){const t=indexedDB.open(e);t.onupgradeneeded=function(){this.result.createObjectStore(e).createIndex("idIndex","_id",{unique:!0})};const r=this.pr(t);this.store=(t,n)=>r.then((r=>n(r.transaction(e,t,{durability:"relaxed"}).objectStore(e))))}pr(e){return new Promise(((t,r)=>{e.oncomplete=e.onsuccess=()=>t(e.result),e.onabort=e.onerror=()=>r(e.error)}))}eachCursor(e,t){return e.openCursor().onsuccess=function(){this.result&&(t(this.result),this.result.continue())},this.pr(e.transaction)}get(e){return this.store("readonly",(t=>this.pr(t.get(e))))}async getBulk(e){return this.store("readonly",(async t=>Promise.all(e.map((e=>this.pr(t.get(e)))))))}set(e,t){return this.store("readwrite",(r=>(r.put(t,e),this.pr(r.transaction))))}setBulk(e){return this.store("readwrite",(t=>(e.forEach((e=>t.put(e[1],e[0]))),this.pr(t.transaction))))}delBulk(e){return this.store("readwrite",(t=>(e.forEach((e=>t.delete(e))),this.pr(t.transaction))))}clear(){return this.store("readwrite",(e=>(e.clear(),this.pr(e.transaction))))}keys(){return this.store("readonly",(async e=>{if(e.getAllKeys)return this.pr(e.getAllKeys());const t=[];return await this.eachCursor(e,(e=>t.push(e.key))),t}))}documents(){return this.store("readonly",(async e=>{if(e.getAll)return this.pr(e.getAll());const t=[];return await this.eachCursor(e,(e=>t.push(e.value))),t}))}async byID(e){return this.store("readonly",(t=>this.pr(t.index("idIndex").getKey(e))))}async length(){return(await this.keys()).length}}const q=(e,t)=>e>t?1:-1;class T{constructor(e,t){this.p=e,this.rdata=t}async setL$(e){await this.p.data.set("$H",{_id:"$H"+e})}async setR$(e){await this.rdata.set("$H",JSON.stringify({_id:"$H"+e}))}async unify$H(){const e=Math.random().toString(36).substring(2);await this.setL$(e),await this.setR$(e)}sync(){return this.p.syncInProgress||this.p.db.deferredDeletes.length+this.p.db.deferredWrites.length?new Promise((e=>{setTimeout((()=>e(this.sync())),0)})):new Promise(((e,t)=>{this.p.syncInProgress=!0,this._sync().then((t=>{e(t)})).catch(t).finally((()=>{this.p.syncInProgress=!1}))}))}async decide(e,t,r){const n=e.split("_")[0],s=e.split("_")[1],i=Number(s.substring(2)),o=r.findIndex((e=>e.startsWith(n+"_")));if(o>-1){const n=r[o].split("_")[1];i>Number(n.substring(2))&&(r.splice(o,1),t.push(e))}else t.push(e)}UCV(e){try{e.$$indexCreated?(this.p.db.indexes[e.$$indexCreated.fieldName]=new I(e.$$indexCreated),this.p.db.indexes[e.$$indexCreated.fieldName].insert(this.p.db.getAllData()),delete this.p.db.indexes[e.$$indexCreated.fieldName]):((e=d(e,this.p._model))._id=r(),this.p.db.addToIndexes(e),this.p.db.removeFromIndexes(e))}catch(t){return e.$$indexCreated?(delete this.p.db.indexes[e.$$indexCreated.fieldName],{type:"index",fieldName:e.$$indexCreated.fieldName,sparse:!!e.$$indexCreated.sparse}):{type:"doc",prop:t.prop,value:t.key}}return!1}async _sync(e=!1){const t=await this.rdata.get("$H")||"0",r=JSON.stringify(await this.p.data.get("$H")||0);if(!e&&(r===t||"0"===r&&(t||"").indexOf("10009")>-1))return{sent:0,received:0,diff:-1};const n=(await this.rdata.keys()).sort(q),s=(await this.p.data.keys()).sort(q);n.splice(n.indexOf("$H"),1),s.splice(s.indexOf("$H"),1);const a=[],h=[],l=n.length;let c=0;const d=s.length;let u=0;for(;c<l||u<d;){let e=n[c],t=s[u];e!==t?u===d||q(t,e)>0?(c++,await this.decide(e,a,h)):(u++,await this.decide(t,h,a)):(c++,u++)}if(0===a.length&&0===h.length)return await this.setL$(t.replace(/.*\$H(.*)"}/,"$1")),{sent:0,received:0,diff:0};const f=[],p=a.length?(await this.rdata.getBulk(a)).map((e=>o(this.p.decode(e||"{}")))):[],y=[];for(let e=0;e<a.length;e++){const t=a[e],r=this.UCV(p[e]);if(r&&"doc"===r.type){const e=r.prop;await this.p.data.set(s.find((t=>t.startsWith(e+"_")))||"",{_id:e,$$indexCreated:{fieldName:e,unique:!1,sparse:this.p.db.indexes[e].sparse}})}else r&&"index"===r.type&&(p[e]={$$indexCreated:{fieldName:r.fieldName,unique:!1,sparse:r.sparse},_id:r.fieldName});const n=t.split("_")[0]+"_",i=s.find((e=>e.startsWith(n)))||"";i&&f.push(i),y.push([t,p[e]])}await this.p.data.delBulk(f),await this.p.data.setBulk(y);const w=[],g=h.length?await this.p.data.getBulk(h):[],m=[];for(let e=0;e<h.length;e++){const t=h[e],r=t.split("_")[0]+"_",s=n.find((e=>e.startsWith(r)))||"";s&&w.push(s),m.push([t,g[e]?this.p.encode(i(g[e])):""])}await this.rdata.delBulk(w),await this.rdata.setBulk(m),await this.p.db.loadDatabase();try{this.p.db.live.update()}catch(e){console.error("XWebDB: Could not do live updates due to an error:",e)}return await this.unify$H(),{sent:h.length,received:a.length,diff:1}}}class M{constructor(e){if(this.ref="",this.syncInterval=0,this.syncInProgress=!1,this.corruptAlertThreshold=.1,this.encode=e=>e,this.decode=e=>e,this.stripDefaults=!1,this._model=X,this.shouldEncode=!1,this._model=e.model||this._model,this.db=e.db,this.ref=this.db.ref,this.data=new C(this.ref),this.stripDefaults=e.stripDefaults||!1,this.RSA=e.syncToRemote,this.syncInterval=e.syncInterval||0,this.RSA){const e=this.RSA(this.ref);this.sync=new T(this,e)}if(this.RSA&&this.syncInterval&&setInterval((async()=>{if(!this.syncInProgress){let e;this.syncInProgress=!0;try{await this.sync._sync()}catch(t){e=t}if(this.syncInProgress=!1,e)throw new Error(e)}}),this.syncInterval),this.corruptAlertThreshold=void 0!==e.corruptAlertThreshold?e.corruptAlertThreshold:.1,e.encode&&!e.decode)throw new Error("XWebDB: encode hook defined but decode hook undefined, cautiously refusing to start Datastore to prevent data loss");if(!e.encode&&e.decode)throw new Error("XWebDB: decode hook defined but encode hook undefined, cautiously refusing to start Datastore to prevent data loss");this.encode=e.encode||this.encode,this.decode=e.decode||this.decode;let t=r();if(this.decode(this.encode(t))!==t)throw new Error("XWebDB: encode is not the reverse of decode, cautiously refusing to start data store to prevent data loss");this.shouldEncode=!!e.encode&&!!e.decode}async writeNewIndex(e){return await this.writeData(e.map((e=>[e.$$indexCreated.fieldName,{_id:e.$$indexCreated.fieldName,...e}])))}async writeNewData(e){e=o(i({t:e})).t;for(let t=0;t<e.length;t++){let r=e[t];r._stripDefaults&&(e[t]=r._stripDefaults())}return await this.writeData(e.map((e=>[e._id,e])))}async loadDatabase(){this.db.q.pause(),this.db.resetIndexes(!0);let e=0,t=0;const r=[],n=await this.readData();for(let s=0;s<n.length;s++){t++;const i=n[s];null!==i?i.$$indexCreated?this.db.indexes[i.$$indexCreated.fieldName]=new I({fieldName:i.$$indexCreated.fieldName,unique:i.$$indexCreated.unique,sparse:i.$$indexCreated.sparse}):r.push(this._model.new(i)):e++}for(let e=0;e<r.length;e++){const t=r[e];this.db.addToIndexes(t)}if(t>0&&e/t>this.corruptAlertThreshold)throw new Error(`XWebDB: More than ${Math.floor(100*this.corruptAlertThreshold)}% of the data file is corrupt, the wrong decode hook might have been used. Cautiously refusing to start Datastore to prevent dataloss`);return this.db.q.start(),!0}async readData(){let e=await this.data.documents(),t=[];for(let r=0;r<e.length;r++){let n=e[r];"object"==typeof n&&null!==n?n._id&&n._id.startsWith("$H")||n.$$deleted||void 0===n._id&&void 0===n.$$indexCreated||(n._encoded&&(n=o(this.decode(n._encoded))),t.push(n)):t.push(null)}return t}async deleteData(e){if(!this.RSA)return await this.data.delBulk(e),e;const t=[],r=[];for(let n=0;n<e.length;n++){const s=e[n],i=await this.data.byID(s)||"",o=Math.random().toString(36).substring(2,4)+Date.now(),a=s+"_"+o;t.push(i.toString()),r.push([a,{_id:s,_rev:o,$$deleted:!0}])}return await this.data.delBulk(t),await this.data.setBulk(r),this.sync&&await this.sync.setL$("updated"),e}async writeData(e){if(!this.RSA)return this.shouldEncode&&(e=e.map((e=>[e[0],{_id:e[1]._id,_encoded:this.encode(i(e[1]))}]))),await this.data.setBulk(e),e.map((e=>e[0]));const t=[],r=[];for(let n=0;n<e.length;n++){const s=e[n],o=await this.data.byID(s[0])||"",a=Math.random().toString(36).substring(2,4)+Date.now(),h=s[0]+"_"+a;s[1]._rev=a,t.push(o.toString()),this.shouldEncode&&(s[1]={_encoded:this.encode(i(s[1])),_id:s[1]._id,_rev:s[1]._rev}),r.push([h,s[1]])}return await this.data.delBulk(t),await this.data.setBulk(r),this.sync&&await this.sync.setL$("updated"),e.map((e=>e[0]))}async deleteEverything(){await this.data.clear()}}class P{constructor(e=1){this._queue=[],this._pause=!1,this._ongoingCount=0,this._concurrency=1,this._resolveEmpty=()=>Promise.resolve(),this._concurrency=e}pause(){this._pause=!0}start(){this._pause=!1,this._next()}add(e){return new Promise(((t,r)=>{const n=async()=>{this._ongoingCount++;try{const r=await Promise.resolve().then(e);return this._ongoingCount--,this._next(),t(r),r}catch(e){return this._ongoingCount--,this._next(),r(e),null}};this._ongoingCount<this._concurrency&&!this._pause?n():this._queue.push(n)}))}get waitingCount(){return this._queue.length}get ongoingCount(){return this._ongoingCount}_next(){if(!(this._ongoingCount>=this._concurrency||this._pause))if(this._queue.length>0){const e=this._queue.shift();e&&e()}else this._resolveEmpty()}}function J(e){return n(JSON.stringify(e))}class R{constructor(e){this.queries=[],this.db=e}addLive(e){return e.id=r(),this.queries.push(e),e.id}async update(){for(let e=0;e<this.queries.length;e++){const t=this.queries[e],r=await this.db.find(t.query);if(J(r)===J(t.observable.observable))continue;let n=await t.observable.unobserve(t.toDBObserver);t.observable.observable.splice(0),t.observable.observable.push(...r),n.length&&t.observable.observe(t.toDBObserver)}}kill(e){const t=this.queries.findIndex((t=>t.id===e));t>-1&&this.queries.splice(t,1)}}class H{constructor(e){this.ref="db",this.timestampData=!1,this.live=new R(this),this.q=new P(1),this.indexes={_id:new I({fieldName:"_id",unique:!0})},this.initIndexes=[],this.defer=!1,this.deferredWrites=[],this.deferredDeletes=[],this.model=e.model||X,e.ref&&(this.ref=e.ref),this.persistence=new M({db:this,model:e.model,encode:e.encode,decode:e.decode,corruptAlertThreshold:e.corruptAlertThreshold||0,syncToRemote:e.syncToRemote,syncInterval:e.syncInterval,stripDefaults:e.stripDefaults}),this.initIndexes=e.indexes||[],this.timestampData=!!e.timestampData,"number"!=typeof e.defer||isNaN(e.defer)||(this.defer=!0,setInterval((async()=>{this.persistence.syncInProgress||this._processDeferred()}),e.defer))}async _processDeferred(){if(this.deferredDeletes.length)try{const e=await this.persistence.deleteData(this.deferredDeletes);this.deferredDeletes=this.deferredDeletes.filter((t=>-1===e.indexOf(t)))}catch(e){console.error("XWebDB: processing deferred deletes error",e),await this.loadDatabase()}if(this.deferredWrites.length)try{const e=await this.persistence.writeNewData(this.deferredWrites);this.deferredWrites=this.deferredWrites.filter((t=>-1===e.indexOf(t._id||"")))}catch(e){console.error("XWebDB: processing deferred writes error",e),await this.loadDatabase()}}async loadDatabase(){const e=await this.persistence.loadDatabase();for(let e=0;e<this.initIndexes.length;e++){const t=this.initIndexes[e];this.indexes[t]||await this.ensureIndex({fieldName:t})}return e}getAllData(){return this.indexes._id.dict.all}resetIndexes(e=!1){Object.keys(this.indexes).forEach((t=>{if(e&&"_id"!==t)return delete this.indexes[t];this.indexes[t].reset()}))}async ensureIndex(e){if(!(e=e||{}).fieldName){let e=new Error("XWebDB: Cannot create an index without a fieldName");throw e.missingFieldName=!0,e}if(this.indexes[e.fieldName])return{affectedIndex:e.fieldName};this.indexes[e.fieldName]=new I(e);try{this.indexes[e.fieldName].insert(this.getAllData())}catch(t){throw delete this.indexes[e.fieldName],t}return await this.persistence.writeNewIndex([{$$indexCreated:e}]),{affectedIndex:e.fieldName}}async removeIndex(e){return delete this.indexes[e],await this.persistence.deleteData([e]),{affectedIndex:e}}addToIndexes(e){let t,r=-1;const n=Object.keys(this.indexes);for(let s=0;s<n.length;s++)try{this.indexes[n[s]].insert(e)}catch(e){r=s,t=e;break}if(t){for(let t=0;t<r;t++)this.indexes[n[t]].remove(e);throw t}}removeFromIndexes(e){Object.keys(this.indexes).forEach((t=>{this.indexes[t].remove(e)}))}updateIndexes(e,t){let r,n=-1;const s=Object.keys(this.indexes);for(let i=0;i<s.length;i++)try{this.indexes[s[i]].update(e,t)}catch(e){n=i,r=e;break}if(r){for(let r=0;r<n;r++)this.indexes[s[r]].revertUpdate(e,t);throw r}}fromDict(e){let t=JSON.parse(JSON.stringify(e)),r=Object.entries(t);r.length&&"$"!==r[0][0][0]&&(t={$noTL:[t]});for(let[e,r]of Object.entries(t))if("$noTL"===e||"$and"===e)for(let e=0;e<r.length;e++){const t=r[e];for(let[e,r]of Object.entries(t)){let t=this.indexes[e];if(!t)continue;r&&0!==Object.keys(r).length&&"$"===Object.keys(r)[0][0]||(r={$eq:r});let n=Object.entries(r);for(let[e,s]of n){if("$not"===e&&null!==s&&"object"==typeof s&&Object.keys(s)&&(s.$eq&&(e="$ne")&&(s=s.$eq),s.$ne&&(e="$eq")&&(s=s.$ne),s.$in&&(e="$nin")&&(s=s.$in),s.$nin&&(e="$in")&&(s=s.$nin),s.$gt&&(e="$lte")&&(s=s.$gt)&&(r.$lte=s),s.$lte&&(e="$gt")&&(s=s.$lte)&&(r.$gt=s),s.$lt&&(e="$gte")&&(s=s.$lt)&&(r.$gte=s),s.$gte&&(e="$lt")&&(s=s.$gte)&&(r.$lt=s)),"$eq"===e)return t.dict.get(s);if("$in"===e)return t.dict.$in(s);if(!(r.$gt||r.$lt||r.$gte||r.lte)){if("$ne"===e)return t.dict.$ne(s);if("$nin"===e)return t.dict.$nin(s)}}if(r.$gt||r.$lt||r.$gte||r.lte)return t.dict.betweenBounds(r.$gt||r.$gte,!!r.$gte,r.$lt||r.$lte,!!r.$lte)}}return null}getCandidates(e){return this.fromDict(e)||this.getAllData()}async insert(e){let t,r=Array.isArray(e)?e:[e],n=[],s=-1;for(let e=0;e<r.length;e++){if(n[e]=d(r[e],this.model),void 0===n[e]._id&&(n[e]._id=this.createNewId()),this.timestampData){let t=new Date;void 0===n[e].createdAt&&(n[e].createdAt=t),void 0===n[e].updatedAt&&(n[e].updatedAt=t)}h(n[e]);try{this.addToIndexes(n[e])}catch(r){t=r,s=e;break}}if(t){for(let e=0;e<s;e++)this.removeFromIndexes(n[e]);throw t}try{this.live.update()}catch(e){console.error("XWebDB: Could not do live updates due to an error:",e)}return this.defer?this.deferredWrites.push(...n):await this.persistence.writeNewData(n),{docs:d(n,this.model),number:n.length}}createNewId(){let e=r();return this.indexes._id.dict.has(e)&&(e=this.createNewId()),e}async count(e){const t=new j(this,e);return(await t.exec()).length}async find(e){const t=new j(this,e);return await t.exec()}cursor(e){return new j(this,e)}async _update(e,t,r){let n=void 0!==r.multi&&r.multi,s=void 0!==r.upsert&&r.upsert;const i=new j(this,e);i.limit(1);const o=i.__exec_unsafe();if(o.length>0){let r=0;const s=this.getCandidates(e),i=[];for(let o=0;o<s.length;o++)if((n||0===r)&&_(s[o],e)){r++;let e=s[o].createdAt,n=O(s[o],t,this.model);e&&(n.createdAt=e),!this.timestampData||void 0!==t.updatedAt||t.$set&&void 0!==t.$set.updatedAt||(n.updatedAt=new Date),i.push({oldDoc:s[o],newDoc:n})}this.updateIndexes(i);try{this.live.update()}catch(e){console.error("XWebDB: Could not do live updates due to an error:",e)}const o=i.map((e=>e.newDoc));return this.defer?this.deferredWrites.push(...o):await this.persistence.writeNewData(o),{number:o.length,docs:o.map((e=>d(e,this.model))),upsert:!1}}if(0===o.length&&s){if(!t.$setOnInsert)throw new Error("XWebDB: $setOnInsert modifier is required when upserting");let e=d(t.$setOnInsert,this.model,!0);return{...await this.insert(e),upsert:!0}}return{number:0,docs:[],upsert:!1}}async update(e,t,r){return await this.q.add((()=>this._update(e,t,r)))}async _remove(e,t){let r=0;const n=[],s=[];let i=!!t&&!!t.multi;this.getCandidates(e).forEach((t=>{_(t,e)&&(i||0===r)&&(r++,s.push(d(t,this.model)),n.push({$$deleted:!0,_id:t._id}),this.removeFromIndexes(t))}));try{this.live.update()}catch(e){console.error("XWebDB: Could not do live updates due to an error:",e)}let o=n.map((e=>e._id||""));return this.defer?this.deferredDeletes.push(...o):await this.persistence.deleteData(o),{number:r,docs:s}}async remove(e,t){return this.q.add((()=>this._remove(e,t)))}}const K={};async function L(e,t="GET",r="",n,s=!0){return new Promise((i=>{var o=new XMLHttpRequest;o.addEventListener("readystatechange",(function(){if(4===this.readyState){if(!1===s)return i(this.responseText);try{let e=JSON.parse(this.responseText);i(e)}catch(e){i(this.responseText)}}})),o.open(t,(e.endpoint+"/"+r).replace(/(https?:\/{2}.*)\/{2}/,"$1/").replace(/\/$/,"")),o.setRequestHeader("Authorization",`Bearer ${e.token}`),o.setRequestHeader("Content-Type","application/json"),o.send(n)}))}class U{constructor({name:e,token:t,endpoint:r}){this.id="",this.name=e,this.token=t,this.endpoint=r,this.connect()}async connect(){if(K[this.endpoint]||(K[this.endpoint]={}),K[this.endpoint][this.name])return void(this.id=K[this.endpoint][this.name]);const e=await this.listStores();for(let t=0;t<e.length;t++){const r=e[t];K[this.endpoint][r.name]=r.id}if(K[this.endpoint][this.name])return void(this.id=K[this.endpoint][this.name]);const t=await this.createStore(this.name);K[this.endpoint][this.name]=t,this.id=t}async listStores(){const e=[];let t=1,r=1;for(;r>=t;){const n=await L(this,"GET",`?page=${t}`);if("string"==typeof n||!n.success||!Array.isArray(n.result))throw new Error("XWebDB: Error while listing namespaces: "+JSON.stringify(n));{const s=n.result;for(let t=0;t<s.length;t++){const r=s[t];e.push({id:r.id,name:r.title})}r=n.result_info.total_pages,t++}}return e}async createStore(e){const t=await L(this,"POST","",JSON.stringify({title:e}));if("string"==typeof t||!t.success||Array.isArray(t.result))throw new Error("XWebDB: Error while creating namespace: "+JSON.stringify(t));return t.result.id}async clear(){this.id||await this.connect();const e=await L(this,"DELETE",this.id);if("string"!=typeof e&&e.success)return!0;throw new Error("XWebDB: Error while deleting namespace: "+JSON.stringify(e))}async del(e){this.id||await this.connect();const t=await L(this,"DELETE",`${this.id}/values/${e}`);if("string"!=typeof t&&t.success)return!0;throw new Error("XWebDB: Error while deleting item: "+JSON.stringify(t))}async set(e,t){this.id||await this.connect();const r=await L(this,"PUT",`${this.id}/values/${e}`,t);if("string"!=typeof r&&r.success)return!0;throw new Error("XWebDB: Error while setting item: "+JSON.stringify(r))}async get(e){this.id||await this.connect();const t=await L(this,"GET",`${this.id}/values/${e}`,void 0,!1);if("string"!=typeof t)throw new Error("XWebDB: Error while getting item: "+JSON.stringify(t));return t}async keys(){this.id||await this.connect();let e=[],t="";do{const r=await L(this,"GET",`${this.id}/keys${t?`?cursor=${t}`:""}`);if("string"==typeof r||!r.success||!Array.isArray(r.result))throw new Error("XWebDB: Error while listing keys: "+JSON.stringify(r));{const n=r.result;for(let t=0;t<n.length;t++){const r=n[t];e.push(r.name)}t=r.result_info.cursor}}while(t);return e}async delBulk(e){this.id||await this.connect();const t=e.reduce(((e,t,r)=>{const n=Math.floor(r/9999);return e[n]||(e[n]=[]),e[n].push(t),e}),[]);let r=[];for(let e=0;e<t.length;e++){const n=t[e],s=await L(this,"DELETE",`${this.id}/bulk`,JSON.stringify(n));if("string"==typeof s||!s.success)throw new Error("XWebDB: Error while deleting item: "+JSON.stringify(s));r.push(!0)}return r}async setBulk(e){this.id||await this.connect();const t=e.reduce(((e,t,r)=>{const n=Math.floor(r/9999);return e[n]||(e[n]=[]),e[n].push(t),e}),[]);let r=[];for(let e=0;e<t.length;e++){const n=t[e],s=await L(this,"PUT",`${this.id}/bulk`,JSON.stringify(n.map((e=>({key:e[0],value:e[1]})))));if("string"==typeof s||!s.success)throw new Error("XWebDB: Error while deleting item: "+JSON.stringify(s));r.push(!0)}return r}async getBulk(e){if(0===e.length)return[];const t=new P(20),r=[];for(let n=0;n<e.length;n++){const s=e[n];r.push(t.add((()=>this.get(s))))}const n=await Promise.all(r),s=[];for(let t=0;t<e.length;t++){let e=n[t];s.push(e)}return s}}var z=Object.freeze({__proto__:null,kvAdapter:(e,t)=>r=>new U({endpoint:e,token:t,name:r})});const F="insert",V="update",G="delete",Y=Symbol.for("object-observer-meta-key-0");function Q(e){return e.parent?Q(e.parent):e}function Z(e){return JSON.parse(JSON.stringify({tmp:e})).tmp}function ee(e,t,r){const n={};n[Y]=t;for(const s in e)n[s]=ie(e[s],s,t,r);return n}function te(e,t,r){let n=e.length;const s=new Array(n);s[Y]=t;for(let i=0;i<n;i++)s[i]=ie(e[i],i,t,r);return s}function re(e,t){try{e(t)}catch(r){console.error(`XWebDB: Failed to notify listener ${e} with ${t}`,r)}}function ne(){const e=this.batches;this.batches=[];for(const[t,r]of e)re(t,r)}function se(e,t){let r=e;const n=t.length;do{let e=r.observers,s=e.length;for(;s--;){let n=e[s];if(t.length){let e;0===r.batches.length&&queueMicrotask(ne.bind(r));for(const t of r.batches)if(t[0]===n){e=t;break}e||(e=[n,[]],r.batches.push(e)),Array.prototype.push.apply(e[1],t)}}const i=r.parent;if(i){for(let e=0;e<n;e++){const n=t[e];t[e]=new ae(n.type,[r.ownKey,...n.path],n.value,n.oldValue,n.object,Z(Q(r).proxy))}r=i}else r=null}while(r)}function ie(e,t,r,n){return void 0!==n&&n.has(e)?null:"object"!=typeof e||null===e?e:Array.isArray(e)?new ce({target:e,ownKey:t,parent:r,visited:n}).proxy:e instanceof Date?e:new le({target:e,ownKey:t,parent:r,visited:n}).proxy}const oe={pop:function(){const e=this[Y],t=e.target,r=t.length-1;let n=t.pop();if(n&&"object"==typeof n){const e=n[Y];e&&(n=e.detach())}return se(e,[new ae(G,[r],void 0,n,this,Z(this))]),n},push:function(){const e=this[Y],t=e.target,r=arguments.length,n=new Array(r),s=t.length;for(let t=0;t<r;t++)n[t]=ie(arguments[t],s+t,e);const i=Reflect.apply(t.push,t,n),o=[];for(let e=s,r=t.length;e<r;e++)o[e-s]=new ae(F,[e],t[e],void 0,this,Z(this));return se(e,o),i},shift:function(){const e=this[Y],t=e.target;let r,n,s,i,o;for(r=t.shift(),r&&"object"==typeof r&&(o=r[Y],o&&(r=o.detach())),n=0,s=t.length;n<s;n++)i=t[n],i&&"object"==typeof i&&(o=i[Y],o&&(o.ownKey=n));return se(e,[new ae(G,[0],void 0,r,this,Z(this))]),r},unshift:function(){const e=this[Y],t=e.target,r=arguments.length,n=new Array(r);for(let t=0;t<r;t++)n[t]=ie(arguments[t],t,e);const s=Reflect.apply(t.unshift,t,n);for(let e,r=0,n=t.length;r<n;r++)if(e=t[r],e&&"object"==typeof e){const t=e[Y];t&&(t.ownKey=r)}const i=n.length,o=new Array(i);for(let e=0;e<i;e++)o[e]=new ae(F,[e],t[e],void 0,this,Z(this));return se(e,o),s},reverse:function(){const e=this[Y],t=e.target;let r,n,s;for(t.reverse(),r=0,n=t.length;r<n;r++)if(s=t[r],s&&"object"==typeof s){const e=s[Y];e&&(e.ownKey=r)}return se(e,[new ae("reverse",[],void 0,void 0,this,Z(this))]),this},sort:function(e){const t=this[Y],r=t.target;let n,s,i;for(r.sort(e),n=0,s=r.length;n<s;n++)if(i=r[n],i&&"object"==typeof i){const e=i[Y];e&&(e.ownKey=n)}return se(t,[new ae("shuffle",[],void 0,void 0,this,Z(this))]),this},fill:function(e,t,r){const n=this[Y],s=n.target,i=[],o=s.length,a=s.slice(0);if(t=void 0===t?0:t<0?Math.max(o+t,0):Math.min(t,o),r=void 0===r?o:r<0?Math.max(o+r,0):Math.min(r,o),t<o&&r>t){let o;s.fill(e,t,r);for(let e,h,l=t;l<r;l++)e=s[l],s[l]=ie(e,l,n),l in a?(h=a[l],h&&"object"==typeof h&&(o=h[Y],o&&(h=o.detach())),i.push(new ae(V,[l],s[l],h,this,Z(this)))):i.push(new ae(F,[l],s[l],void 0,this,Z(this)));se(n,i)}return this},copyWithin:function(e,t,r){const n=this[Y],s=n.target,i=s.length;e=e<0?Math.max(i+e,0):e,t=void 0===t?0:t<0?Math.max(i+t,0):Math.min(t,i),r=void 0===r?i:r<0?Math.max(i+r,0):Math.min(r,i);const o=Math.min(r-t,i-e);if(e<i&&e!==t&&o>0){const i=s.slice(0),a=[];s.copyWithin(e,t,r);for(let t,r,h,l=e;l<e+o;l++)t=s[l],t&&"object"==typeof t&&(t=ie(t,l,n),s[l]=t),r=i[l],r&&"object"==typeof r&&(h=r[Y],h&&(r=h.detach())),"object"!=typeof t&&t===r||a.push(new ae(V,[l],t,r,this,Z(this)));se(n,a)}return this},splice:function(){const e=this[Y],t=e.target,r=arguments.length,n=new Array(r),s=t.length;for(let t=0;t<r;t++)n[t]=ie(arguments[t],t,e);const i=0===r?0:n[0]<0?s+n[0]:n[0],o=r<2?s-i:n[1],a=Math.max(r-2,0),h=Reflect.apply(t.splice,t,n),l=t.length;let c,d,u,f;for(let e,r=0;r<l;r++)e=t[r],e&&"object"==typeof e&&(c=e[Y],c&&(c.ownKey=r));for(d=0,u=h.length;d<u;d++)f=h[d],f&&"object"==typeof f&&(c=f[Y],c&&(h[d]=c.detach()));const p=[];let y;for(y=0;y<o;y++)y<a?p.push(new ae(V,[i+y],t[i+y],h[y],this,Z(this))):p.push(new ae(G,[i+y],void 0,h[y],this,Z(this)));for(;y<a;y++)p.push(new ae(F,[i+y],t[i+y],void 0,this,Z(this)));return se(e,p),h}};class ae{constructor(e,t,r,n,s,i){this.type=e,this.path=t,this.value=Z(r),this.oldValue=Z(n),this.object=s,this.snapshot=i}}class he{constructor(e,t){this.observers=[],this.batches=[];const{target:r,parent:n,ownKey:s,visited:i=new Set}=e;n&&void 0!==s?(this.parent=n,this.ownKey=s):(this.parent=null,this.ownKey=""),i.add(r);const o=t(r,this,i);i.delete(r),this.revocable=Proxy.revocable(o,this),this.proxy=this.revocable.proxy,this.target=o,this.batches=[]}detach(){return this.parent=null,this.target}set(e,t,r){let n=e[t];if(r!==n){const s=ie(r,t,this);if(e[t]=s,n&&"object"==typeof n){const e=n[Y];e&&(n=e.detach())}se(this,void 0===n?[new ae(F,[t],s,void 0,this.proxy,Z(this.proxy))]:[new ae(V,[t],s,n,this.proxy,Z(this.proxy))])}return!0}deleteProperty(e,t){let r=e[t];if(delete e[t],r&&"object"==typeof r){const e=r[Y];e&&(r=e.detach())}return se(this,[new ae(G,[t],void 0,r,this.proxy,Z(this.proxy))]),!0}}class le extends he{constructor(e){super(e,ee)}}class ce extends he{constructor(e){super(e,te)}get(e,t){return oe[t]||e[t]}}function de(e){const t=ue(e)?e:new ce({target:e,ownKey:"",parent:null}).proxy;async function r(e){return e?Array.isArray(e)?await fe(t,e):await fe(t,[e]):await fe(t)}function n(e){!function(e,t){const r=e[Y].observers;r.some((e=>e===t))||r.push(t)}(t,e)}return{observe:n,unobserve:r,silently:async function(e){const s=await r();await e(t),s.forEach((e=>n(e)))},observable:t}}function ue(e){return!(!e||!e[Y])}async function fe(e,t){e instanceof Promise&&(e=await Promise.resolve(e));const r=e[Y].observers;if(!r.length)return[];if(!t)return r.splice(0);let n=[];for(let e=0;e<t.length;e++){const s=t[e],i=r.indexOf(s);i>-1&&n.push(r.splice(i,1)[0])}return n}var pe=Object.freeze({__proto__:null,observable:de,isObservable:ue,Change:ae});let ye=k;const we={observable:pe,Cursor:j,customUtils:s,Datastore:H,Index:I,modelling:E,Q:P,Persistence:M,Dictionary:N};e.Database=class{constructor(e){this.create=this.insert,this.find=this.read,this.number=this.count,this.remove=this.delete,this.ensureIndex=this.createIndex,this.model=e.model||X,this.ref=e.ref,this._datastore=new H({ref:this.ref,model:this.model,indexes:e.indexes,encode:e.encode,decode:e.decode,corruptAlertThreshold:e.corruptAlertThreshold,timestampData:e.timestampData,syncToRemote:e.sync?e.sync.syncToRemote:void 0,syncInterval:e.sync?e.sync.syncInterval:void 0,defer:e.deferPersistence,stripDefaults:e.stripDefaults||!1}),this.loaded=this._datastore.loadDatabase()}async insert(e){return await this._datastore.insert(e)}async live(e={},{skip:t=0,limit:r=0,project:n={},sort:s={},toDB:i=!0,fromDB:o=!0}={}){const a=de(await this.read(...arguments));let h=()=>{},l="";return i&&(h=e=>{let t={};for(let r=0;r<e.length;r++){const n=e[r];if(0!==n.path.length&&"shuffle"!==n.type&&"reverse"!==n.type)if(1===n.path.length&&"update"===n.type){let e=n.snapshot[n.path[0]],r=n.oldValue._id;t[r]=()=>this.update({_id:r},{$set:e})}else if(n.path.length>1||"update"===n.type){let e=n.snapshot[n.path[0]],r=e._id;t[r]=()=>this.upsert({_id:r},{$set:e,$setOnInsert:e})}else if("delete"===n.type){let e=n.oldValue._id;t[e]=()=>this.delete({_id:e})}else if("insert"===n.type){let e=n.value;t[e._id]=()=>this.insert(e)}}const r=Object.values(t).map((e=>e()));Promise.all(r).catch((e=>{this._datastore.live.update(),console.error("XWebDB: Reflecting observable changes to database couldn't complete due to an error:",e)}))},a.observe(h)),o&&(l=this._datastore.live.addLive({query:e,toDBObserver:h,observable:a})),{...a,kill:async e=>{"toDB"!==e&&e||await a.unobserve(h),"fromDB"!==e&&e||this._datastore.live.kill(l)}}}async read(e={},{skip:t=0,limit:r=0,project:n={},sort:s={}}={}){e=f(e),s=f(s),n=f(n);const i=this._datastore.cursor(e);return s&&i.sort(s),t&&i.skip(t),r&&i.limit(r),n&&i.projection(n),await i.exec()}async update(e,t,r=!1){e=f(e||{});for(let e=0;e<ye.length;e++){const r=ye[e];t[r]&&(t[r]=f(t[r]))}return await this._datastore.update(e,t,{multi:r,upsert:!1})}async upsert(e,t,r=!1){e=f(e||{});for(let e=0;e<ye.length;e++){const r=ye[e];t[r]&&(t[r]=f(t[r]))}return await this._datastore.update(e,t,{multi:r,upsert:!0})}async count(e={}){return e=f(e||{}),await this._datastore.count(e)}async delete(e,t=!1){e=f(e||{});return await this._datastore.remove(e,{multi:t||!1})}async createIndex(e){return await this._datastore.ensureIndex(e)}async removeIndex(e){return await this._datastore.removeIndex(e)}async reload(){return await this._datastore.loadDatabase()}async sync(){if(!this._datastore.persistence.sync)throw new Error("XWebDB: Can not perform sync operation unless provided with remote DB adapter");return await this._datastore.persistence.sync.sync()}async forceSync(){if(!this._datastore.persistence.sync)throw new Error("XWebDB: Can not perform sync operation unless provided with remote DB adapter");return await this._datastore.persistence.sync._sync(!0)}get syncInProgress(){return this._datastore.persistence.syncInProgress}},e.Doc=X,e.SubDoc=class extends S{},e._internal=we,e.adapters=z,e.mapSubModel=function(e,t){return{_$SHOULD_MAP$_:!0,def:t,ctr:e}},Object.defineProperty(e,"__esModule",{value:!0})}));