!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).xwebdb={})}(this,(function(e){"use strict";const t=[];for(let e=0;e<256;e++)t[e]=(e<16?"0":"")+e.toString(16);function r(){let e=4294967295*Math.random()|0,r=4294967295*Math.random()|0,s=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return t[255&e]+t[e>>8&255]+t[e>>16&255]+t[e>>24&255]+"-"+t[255&r]+t[r>>8&255]+"-"+t[r>>16&15|64]+t[r>>24&255]+"-"+t[63&s|128]+t[s>>8&255]+"-"+t[s>>16&255]+t[s>>24&255]+t[255&i]+t[i>>8&255]+t[i>>16&255]+t[i>>24&255]}function s(e){for(var t=e.length,r=-1,s=0;s<t;++s)r=(r<<5)+r+e.charCodeAt(s)&4294967295;return r>>>0}var i=Object.freeze({__proto__:null,uid:r,dHash:s});function n(e,t=!1){return JSON.stringify(e,(function(e,r){if(t||a(e,r),void 0!==r)return null===r?null:"function"==typeof this[e].getTime?{$$date:this[e].getTime()}:r}))}function o(e){return JSON.parse(e,(function(e,t){if("$$date"===e)return new Date(t);let r=typeof t;return"string"===r||"number"===r||"boolean"===r||null===t?t:t&&t.$$date?t.$$date:t}))}function a(e,t){if("number"==typeof e&&(e=e.toString()),!("$"!==e[0]||"$$date"===e&&"number"==typeof t||"$$deleted"===e&&!0===t||"$$indexCreated"===e||"$$indexRemoved"===e))throw new Error("XWebDB: Field names cannot begin with the $ character");if(-1!==e.indexOf("."))throw new Error("XWebDB: Field names cannot contain a .")}function h(e){if(Array.isArray(e))e.forEach((e=>h(e)));else if(c(e)&&!(e instanceof Date))for(const[t,r]of Object.entries(e))a(t,r),h(r)}function l(e){return!c(e)}function c(e){return!("object"!=typeof e||null===e||e instanceof Date||Array.isArray(e))}function d(e,t,r=!1){let s=typeof e;if("boolean"===s||"number"===s||"string"===s)return e;if(null===e||e instanceof Date)return e;if(Array.isArray(e))return e.map((e=>d(e,t,r)));if("object"==typeof e){let s={};for(const[i,n]of Object.entries(e))(!r||"$"!==i[0]&&-1===i.indexOf("."))&&(s[i]=d(n,t,r));return s.hasOwnProperty("_id")?t.new(s):s}return JSON.parse(JSON.stringify({temp:e})).temp}function u(e,t){const r="string"==typeof t?t.split("."):t;if(e){if(0===r.length)return e;if(1===r.length)return e[r[0]];if(Array.isArray(e[r[0]])){let t=parseInt(r[1],10);if("number"==typeof t&&!isNaN(t))return u(e[r[0]][t],r.slice(2));let s=new Array;for(let t=0;t<e[r[0]].length;t+=1)s.push(u(e[r[0]][t],r.slice(1)));return s}return u(e[r[0]],r.slice(1))}}function f(e){const t={};!function e(r,s=""){for(const i in r)if(r.hasOwnProperty(i)){const n=s?`${s}.${i}`:i,o=r[i];!Array.isArray(o)&&"object"==typeof o&&null!==o&&Object.keys(o).length&&-1===Object.keys(o).join("").indexOf("$")?e(o,n):t[n]=o}}(e.$deep);const r=Object.assign(e,t);return delete r.$deep,r}function p(e,t){let r=typeof e,s=typeof t;return null===e||"string"===r||"boolean"===r||"number"===r||null===t||"string"===s||"boolean"===s||"number"===s?e===t:e instanceof Date||t instanceof Date?e instanceof Date&&t instanceof Date&&e.getTime()===t.getTime():!(!(Array.isArray(e)&&Array.isArray(t)||!Array.isArray(e)&&!Array.isArray(t))||void 0===e||void 0===t)&&n({temp:e},!0)===n({temp:t},!0)}function y(e,t){let r=typeof e,s=typeof t;return("string"===r||"number"===r||"string"===s||"number"===s||e instanceof Date||t instanceof Date)&&r===s}function w(e,t){return e<t?-1:e>t?1:0}function g(e,t){if(void 0===e)return void 0===t?0:-1;if(void 0===t)return 1;if(null===e)return null===t?0:-1;if(null===t)return 1;let r=typeof e,s=typeof t;if("number"===r)return"number"==typeof t?w(e,t):-1;if("number"===s)return 1;if("string"===r)return"string"===s?w(e,t):-1;if("string"===s)return 1;if("boolean"===r)return"boolean"===s?w(e,t):-1;if("boolean"===s)return 1;if(e instanceof Date)return t instanceof Date?w(e.getTime(),t.getTime()):-1;if(t instanceof Date)return 1;if(Array.isArray(e))return Array.isArray(t)?function(e,t){for(let r=0;r<Math.min(e.length,t.length);r+=1){let s=g(e[r],t[r]);if(0!==s)return s}return w(e.length,t.length)}(e,t):-1;if(Array.isArray(t))return 1;let i=Object.keys(e).sort(),n=Object.keys(t).sort();for(let r=0;r<Math.min(i.length,n.length);r+=1){let s=g(e[i[r]],t[n[r]]);if(0!==s)return s}return w(i.length,n.length)}const b={$size:function(e,t){if(!Array.isArray(e))return!1;if("number"!=typeof t||t%1!=0)throw new Error("XWebDB: $size operator called without an integer");return e.length===t},$elemMatch:function(e,t){if(!Array.isArray(e))return!1;let r=e.length;for(;r--;)if(_(e[r],t))return!0;return!1},$all:function(e,t){if(!Array.isArray(e))throw new Error("XWebDB: $all must be applied on fields of type array");if(!Array.isArray(t))throw new Error("XWebDB: $all must be supplied with argument of type array");for(let r=0;r<t.length;r++)if(-1===e.indexOf(t[r]))return!1;return!0}},m={$type:function(e,t){return["number","boolean","string","undefined"].indexOf(t)>-1?typeof e===t:"array"===t?Array.isArray(e):"null"===t?null===e:"date"===t?e instanceof Date:"object"===t&&!("object"!=typeof e||e instanceof Date||null===e||Array.isArray(e))},$not:(e,t)=>!_({k:e},{k:t}),$eq:(e,t)=>p(e,t),$lt:(e,t)=>y(e,t)&&e<t,$lte:(e,t)=>y(e,t)&&e<=t,$gt:(e,t)=>y(e,t)&&e>t,$gte:(e,t)=>y(e,t)&&e>=t,$mod:function(e,t){if(!Array.isArray(t))throw new Error("XWebDB: malformed mod, must be supplied with an array");if(2!==t.length)throw new Error("XWebDB: malformed mod, array length must be exactly two, a divisor and a remainder");return e%t[0]===t[1]},$ne:function(e,t){return void 0===e||!p(e,t)},$in:function(e,t){if(!Array.isArray(t))throw new Error("XWebDB: $in operator called with a non-array");for(let r=0;r<t.length;r+=1)if(p(e,t[r]))return!0;return!1},$nin:function(e,t){if(!Array.isArray(t))throw new Error("XWebDB: $nin operator called with a non-array");return!m.$in(e,t)},$regex:function(e,t){if(!(t instanceof RegExp))throw new Error("XWebDB: $regex operator called with non regular expression");return"string"==typeof e&&t.test(e)},$exists:function(e,t){return t=!(!t&&""!==t),void 0===e?!t:t},...b};function $(e,t,r){if(!Array.isArray(r))throw new Error("XWebDB: $or/$nor/$and operators should be used with an array");for(let s=0;s<r.length;s+=1){if(_(t,r[s])){if("$or"===e)return!0;if("$nor"===e)return!1}else if("$and"===e)return!1}return"$or"!==e}const v={$and:(e,t)=>$("$and",e,t),$nor:(e,t)=>$("$nor",e,t),$or:(e,t)=>$("$or",e,t),$where:(e,t)=>{if("function"!=typeof t)throw new Error("XWebDB: $where operator used without a function");let r=t.call(e);if("boolean"!=typeof r)throw new Error("XWebDB: $where function must return boolean");return r}};function _(e,t){let r=!1,s=Object.keys(t);for(let e=0;e<s.length;e++){const t=s[e];if(m[t]){r=!0;break}}if(l(e)||l(t)||r)return D({TMP:e},"TMP",t);for(let r=0;r<s.length;r+=1){let i=s[r],n=t[i];if("$"===i[0]){let t=v[i];if(!t)throw new Error("XWebDB: Unknown logical operator "+i);if(!t(e,n))return!1}else if(!D(e,i,n))return!1}return!0}function D(e,t,r,s){const i=u(e,t);if(Array.isArray(i)&&!s){if(Array.isArray(r))return D(e,t,r,!0);if(null!==r&&"object"==typeof r&&!(r instanceof RegExp)){let s=Object.keys(r);for(let i=0;i<s.length;i+=1)if(b[s[i]])return D(e,t,r,!0)}if(r.$ne&&-1!==i.indexOf(r.$ne))return!1;if(Array.isArray(r.$nin)&&r.$nin.filter((e=>-1!==i.indexOf(e))).length)return!1;for(let e=0;e<i.length;e+=1)if(D({TMP:i[e]},"TMP",r))return!0;return!1}if(!("object"!=typeof r||null===r||r instanceof RegExp||Array.isArray(r))){let e=Object.keys(r),t=e.map((e=>e[0])),s=t.filter((e=>"$"===e));if(0!==s.length&&s.length!==t.length)throw new Error("XWebDB: You cannot mix operators and normal fields");if(s.length>0){for(let t=0;t<e.length;t+=1){if(!m[e[t]])throw new Error("XWebDB: Unknown comparison function "+e[t]);if(!m[e[t]](i,r[e[t]]))return!1}return!0}}return r instanceof RegExp?m.$regex(i,r):!!p(i,r)}const x={$set:function(e,t,r){e&&(e[t]=r)},$mul:function(e,t,r){let s=e[t];if("number"!=typeof r||"number"!=typeof s)throw new Error("XWebDB: Multiply operator works only on numbers");e[t]=s*r},$unset:function(e,t){Array.isArray(e)?e.splice(Number(t),1):delete e[t]},$push:function(e,t,r){if(e.hasOwnProperty(t)||(e[t]=[]),!Array.isArray(e[t]))throw new Error("XWebDB: Can't $push an element on non-array values");if(null!==r&&"object"==typeof r&&r.$slice&&void 0===r.$each&&(r.$each=[]),null!==r&&"object"==typeof r&&r.$each){const s=r.$each,i=r.$slice,n=r.$position,o=r.$sort,a=Object.keys(r);if(a.length>1&&a.filter((e=>-1===["$each","$slice","$position","$sort"].indexOf(e))).length)throw new Error("XWebDB: Can only use the known modifiers $slice, $position and $sort in conjunction with $each when $push to array");if(!Array.isArray(s))throw new Error("XWebDB: $each requires an array value");if(void 0!==i&&"number"!=typeof i)throw new Error("XWebDB: $slice requires a number value");if(n)for(let r=0;r<s.length;r++)e[t].splice(n+r,0,s[r]);else s.forEach((r=>e[t].push(r)));if(o&&("number"==typeof o?1===o?e[t].sort(((e,t)=>g(e,t))):e[t].sort(((e,t)=>g(t,e))):e[t].sort(((e,t)=>{const r=Object.keys(o);for(let s=0;s<r.length;s++){const i=r[s];if(1===o[i]){const r=g(e[i],t[i]);if(r)return r}else{const r=g(t[i],e[i]);if(r)return r}}return 0}))),0===i)e[t]=[];else if("number"==typeof i){let r=0,s=0,n=e[t].length;i<0?(r=Math.max(0,n+i),s=n):i>0&&(r=0,s=Math.min(n,i)),e[t]=e[t].slice(r,s)}}else e[t].push(r)},$addToSet:function(e,t,r){if(e.hasOwnProperty(t)||(e[t]=[]),!Array.isArray(e[t]))throw new Error("XWebDB: Can't $addToSet an element on non-array values");const s=r?r.$each:void 0;if(null!==r&&"object"==typeof r&&s){if(Object.keys(r).length>1)throw new Error("XWebDB: Can't use another field in conjunction with $each on $addToSet modifier");if(!Array.isArray(s))throw new Error("XWebDB: $each requires an array value");s.forEach((r=>x.$addToSet(e,t,r)))}else{let s=!0;for(let i=0;i<e[t].length;i++){if(0===g(e[t][i],r)){s=!1;break}}s&&e[t].push(r)}},$pop:function(e,t,r){if(!Array.isArray(e[t]))throw new Error("XWebDB: Can't $pop an element from non-array values");if("number"!=typeof r||r%1!=0)throw new Error("XWebDB: "+r+" isn't an integer, can't use it with $pop");0!==r&&(e[t]=r>0?e[t].slice(0,e[t].length-1):e[t].slice(1))},$pull:function(e,t,r){if(!Array.isArray(e[t]))throw new Error("XWebDB: Can't $pull an element from non-array values");let s=e[t];for(let e=s.length-1;e>=0;e-=1)_(s[e],r)&&s.splice(e,1)},$pullAll:function(e,t,r){if(!Array.isArray(e[t]))throw new Error("XWebDB: Can't $pull an element from non-array values");let s=e[t];for(let e=s.length-1;e>=0;e-=1)for(let t=0;t<r.length;t++)_(s[e],r[t])&&s.splice(e,1)},$inc:function(e,t,r){if("number"!=typeof r)throw new Error("XWebDB: "+r+" must be a number");if("number"!=typeof e[t]){if(e.hasOwnProperty(t))throw new Error("XWebDB: Can't use the $inc modifier on non-number fields");e[t]=r}else e[t]=e[t]+r},$max:function(e,t,r){(void 0===e[t]||r>e[t])&&(e[t]=r)},$min:function(e,t,r){(void 0===e[t]||r<e[t])&&(e[t]=r)},$currentDate:function(e,t,r){if(!0===r)e[t]=new Date;else if(r.$type&&"timestamp"===r.$type)e[t]=Date.now();else{if(!r.$type||"date"!==r.$type)throw new Error("XWebDB: Malformed $currentDate update query");e[t]=new Date}},$rename:function(e,t,r){if(Array.isArray(e)){let s=Number(r),i=Number(t);e.splice(s,0,e.splice(i,1)[0])}else e[r]=e[t],delete e[t]},$setOnInsert:function(){}},A={},k=Object.keys(x);for(let e=0;e<k.length;e++){const t=k[e];A[t]=(e,r,s)=>{var i="string"==typeof r?r.split("."):r;if(1===i.length)x[t](e,r,s);else{if(void 0===e[i[0]]){if("$unset"===t)return;e[i[0]]={}}let r=i.slice(1).join(".");A[t](e[i[0]],r,s)}}}function j(e,t,r){const s=Object.keys(t),i=s.map((e=>e.charAt(0))),n=i.filter((e=>"$"===e));if(-1!==s.indexOf("_id")&&t._id!==e._id)throw new Error("XWebDB: You cannot change a document's _id");if(0!==n.length&&n.length!==i.length)throw new Error("XWebDB: You cannot mix modifiers and normal fields");let o;if(0===n.length)o=d(t,r),o._id=e._id;else{const i=Array.from(new Set(s));o=d(e,r);for(let e=0;e<i.length;e++){const r=i[e],s=t[r];if(!A[r])throw new Error("XWebDB: Unknown modifier "+r);if("object"!=typeof s)throw new Error("XWebDB: Modifier "+r+"'s query must be an object");const n=Object.keys(s);for(let e=0;e<n.length;e++){const t=n[e];A[r](o,t,s[t])}}}if(h(o),e._id!==o._id)throw new Error("XWebDB: You cannot change a document's _id");return o}function O(e,t){return e.sort(((e,r)=>{for(const[s,i]of Object.entries(t||{})){let t=i*g(u(e,s),u(r,s));if(0!==t)return t}return 0}))}class B{static new(e){const t=new this;if("object"!=typeof e||null===e)return t;const r=Object.keys({...t,...e});for(let s=0;s<r.length;s++){const i=r[s];let n=t[i],o=e[i];n&&n._$SHOULD_MAP$_?void 0===o?t[i]=n.def:Array.isArray(o)?t[i]=o.map((e=>n.ctr.new(e))):t[i]=n.ctr.new(o):t[i]=void 0===o?n:o}return t}_stripDefaults(){this.constructor._$def||(this.constructor._$def=this.constructor.new({}));let e=this.constructor._$def;const t={};for(const[r,s]of Object.entries(this)){const i=e[r];Array.isArray(s)&&s[0]&&s[0]._stripDefaults?(t[r]=s.map((e=>e._stripDefaults())),0===t[r].length&&delete t[r]):"object"==typeof s&&null!==s&&s._stripDefaults?(t[r]=s._stripDefaults(),0===Object.keys(t[r]).length&&delete t[r]):JSON.stringify(i)!==JSON.stringify(s)&&(t[r]=s)}return t}}class N extends B{constructor(){super(...arguments),this._id=r()}}function I(e,t,r=N){if(void 0===t||0===Object.keys(t).length)return e;let s=[],i=0!==t._id;delete t._id;let n=Object.keys(t),o=n.map((e=>t[e])).sort();if(o[0]!==o[o.length-1])throw new Error("XWebDB: Can't both keep and omit fields except for _id");for(let t=0;t<e.length;t++){const a=e[t];let h={};if(1===o[0]){h={$set:{}};for(let e=0;e<n.length;e++){const t=n[e];h.$set[t]=u(a,t),void 0===h.$set[t]&&delete h.$set[t]}h=j({},h,r)}else h={$unset:{}},n.forEach((e=>h.$unset[e]=!0)),h=j(a,h,r);i?h._id=a._id:delete h._id,s.push(h)}return s}var E=Object.freeze({__proto__:null,toDotNotation:f,serialize:n,deserialize:o,clone:d,validateObject:h,isPrimitiveType:l,modify:j,fromDotNotation:u,match:_,compare:g,modifiersKeys:k,equal:p,sort:O,project:I});class W{constructor(e,t){this.db=e,this._query=t||{}}limit(e){return this._limit=e,this}skip(e){return this._skip=e,this}sort(e){return this._sort=e,this}project(e){return this._proj=e,this}_doProject(e){return void 0===this._proj||0===Object.keys(this._proj).length?e:I(e,this._proj,this.db.model)}_doSort(e){return void 0===this._sort||0===Object.keys(this._sort).length?e:O(e,this._sort)}__exec_unsafe(){let e=[],t=this.db.cache.get(this._query);if(t)e=t;else{const t=this.db.getCandidates(this._query);for(let r=0;r<t.length;r++)_(t[r],this._query)&&e.push(t[r]);this.db.cache.storeOrProspect(this._query,e)}if(this._sort&&(e=this._doSort(e)),this._limit||this._skip){const t=this._limit||e.length,r=this._skip||0;e=e.slice(r,r+t)}return this._proj&&(e=this._doProject(e)),e}exec(){const e=this.__exec_unsafe(),t=[];for(let r=0;r<e.length;r++)t.push(d(e[r],this.db.model));return t}}function C(e){let t=typeof e;return"number"===t||"string"===t||"bigint"===t?e:JSON.stringify([[[e]]])}class q{constructor({fieldName:e,unique:t,c:r}){this.keys=[],this.documents=new Map,this.unique=!1,this.fieldName=e,this.comparator=r,this.unique=t}has(e){return this.documents.has(C(e))}insert(e,t){e=C(e);let r=this.documents.get(e);if(r&&this.unique){const t=new Error(`XWebDB: Can't insert key ${e}, it violates the unique constraint`);throw t.key=e,t.prop=this.fieldName,t.errorType="uniqueViolated",t}const s=this.findInsertionIndex(e);this.keys[s]!==e&&this.keys.splice(s,0,e),r||(r=[],this.documents.set(e,r)),r.push(t)}get(e){return Array.isArray(e)?e.map((e=>this.get(C(e)))).flat(1):this.documents.get(C(e))||[]}delete(e,t){e=C(e);const r=this.binarySearch(e);if(-1===r)return!1;const s=this.documents.get(e)||[];return s.splice(s.indexOf(t),1),0===s.length&&(this.keys.splice(r,1),this.documents.delete(e)),!0}findInsertionIndex(e){e=C(e);let t=0,r=this.keys.length;for(;t<r;){const s=Math.floor((t+r)/2);-1===this.comparator(this.keys[s],e)?t=s+1:r=s}return t}binarySearch(e){e=C(e);let t=0,r=this.keys.length-1;for(;t<=r;){const s=Math.floor((t+r)/2);if(0===this.comparator(this.keys[s],e))return s;-1===this.comparator(this.keys[s],e)?t=s+1:r=s-1}return-1}$in(e){e=e.map((e=>C(e)));let t=[];for(let r=0;r<e.length;r++){let s=C(e[r]);t=t.concat(this.get(s))}return t.filter(((e,r)=>t.indexOf(e)===r))}$nin(e){e=e.map((e=>C(e)));let t=[];for(let r=0;r<this.keys.length;r++){let s=C(this.keys[r]);e.includes(s)||(t=t.concat(this.get(s)))}return t}$ne(e){e=C(e);let t=[];for(let r=0;r<this.keys.length;r++){const s=C(this.keys[r]);0!==this.comparator(e,s)&&(t=t.concat(this.get(s)))}return t}betweenBounds(e,t,r,s){let i=0,n=this.keys.length-1,o=[];for(;i<=n;){let a=Math.floor((i+n)/2),h=this.keys[a];if(h<e||!t&&h===e)i=a+1;else{if(!(h>r||!s&&h===r)){o.push(a);for(let r=a-1;r>=i;r--){let s=this.keys[r];if(s<e||!t&&s===e)break;o.push(r)}for(let e=a+1;e<=n;e++){let t=this.keys[e];if(t>r||!s&&t===r)break;o.push(e)}break}n=a-1}}o.sort(((e,t)=>e===t?0:e>t?1:-1));let a=[];for(let e=0;e<o.length;e++){const t=o[e];a=a.concat(this.get(this.keys[t]))}return a}boundedQuery(e){return this.betweenBounds(e.$gt||e.$gte,!!e.$gte,e.$lt||e.$lte,!!e.$lte)}get all(){return Array.from(this.documents.values()).flat()}get numberOfKeys(){return this.keys.length}get size(){return this.all.length}}function X(e){return Array.from(new Set(e.map((e=>{return null===(t=e)?"$NU":"string"==typeof t?"$ST"+t:"boolean"==typeof t?"$BO"+t:"number"==typeof t?"$NO"+t:t instanceof Date?"$DA"+t.getTime():t;var t})))).map((e=>"string"==typeof e?e.substring(3):e))}class S{constructor({fieldName:e,unique:t,sparse:r}){this.unique=!1,this.sparse=!1,this.fieldName=e,this.unique=!!t,this.sparse=!!r,this.dict=new q({unique:this.unique,c:g,fieldName:this.fieldName})}reset(){this.dict=new q({unique:this.unique,c:g,fieldName:this.fieldName})}insert(e){if(Array.isArray(e))return this.insertMultipleDocs(e);let t=u(e,this.fieldName);if(void 0!==t||!this.sparse)if(Array.isArray(t)){let r,s=X(t),i=-1;for(let t=0;t<s.length;t++)try{this.dict.insert(s[t],e)}catch(e){r=e,i=t;break}if(r){for(let t=0;t<i;t++)this.dict.delete(s[t],e);throw r}}else this.dict.insert(t,e)}insertMultipleDocs(e){let t,r=-1;for(let s=0;s<e.length;s++)try{this.insert(e[s])}catch(e){t=e,r=s;break}if(t){for(let t=0;t<r;t++)this.remove(e[t]);throw t}}remove(e){if(Array.isArray(e))return e.forEach((e=>this.remove(e)));let t=u(e,this.fieldName);void 0===t&&this.sparse||(Array.isArray(t)?X(t).forEach((t=>this.dict.delete(t,e))):this.dict.delete(t,e))}update(e,t){if(Array.isArray(e))this.updateMultipleDocs(e);else if(t){this.remove(e);try{this.insert(t)}catch(t){throw this.insert(e),t}}}updateMultipleDocs(e){let t,r=-1;for(let t=0;t<e.length;t++)this.remove(e[t].oldDoc);for(let s=0;s<e.length;s++)try{this.insert(e[s].newDoc)}catch(e){t=e,r=s;break}if(t){for(let t=0;t<r;t++)this.remove(e[t].newDoc);for(let t=0;t<e.length;t++)this.insert(e[t].oldDoc);throw t}}revertUpdate(e,t){var r=[];!Array.isArray(e)&&t?this.update(t,e):Array.isArray(e)&&(e.forEach((e=>{r.push({oldDoc:e.newDoc,newDoc:e.oldDoc})})),this.update(r))}}class M{constructor(e){const t=indexedDB.open(e);t.onupgradeneeded=function(){this.result.createObjectStore(e).createIndex("idIndex","_id",{unique:!0})};const r=this.pr(t);this.store=(t,s)=>r.then((r=>s(r.transaction(e,t,{durability:"relaxed"}).objectStore(e))))}pr(e){return new Promise(((t,r)=>{e.oncomplete=e.onsuccess=()=>t(e.result),e.onabort=e.onerror=()=>r(e.error)}))}eachCursor(e,t){return e.openCursor().onsuccess=function(){this.result&&(t(this.result),this.result.continue())},this.pr(e.transaction)}get(e){return this.store("readonly",(t=>this.pr(t.get(e))))}async getBulk(e){return this.store("readonly",(async t=>Promise.all(e.map((e=>this.pr(t.get(e)))))))}set(e,t){return this.store("readwrite",(r=>(r.put(t,e),this.pr(r.transaction))))}setBulk(e){return this.store("readwrite",(t=>(e.forEach((e=>t.put(e[1],e[0]))),this.pr(t.transaction))))}delBulk(e){return this.store("readwrite",(t=>(e.forEach((e=>t.delete(e))),this.pr(t.transaction))))}clear(){return this.store("readwrite",(e=>(e.clear(),this.pr(e.transaction))))}keys(){return this.store("readonly",(async e=>{if(e.getAllKeys)return this.pr(e.getAllKeys());const t=[];return await this.eachCursor(e,(e=>t.push(e.key))),t}))}documents(){return this.store("readonly",(async e=>{if(e.getAll)return this.pr(e.getAll());const t=[];return await this.eachCursor(e,(e=>t.push(e.value))),t}))}async byID(e){return this.store("readonly",(t=>this.pr(t.index("idIndex").getKey(e))))}async length(){return(await this.keys()).length}}const T=(e,t)=>e>t?1:-1;class P{constructor(e,t){this.p=e,this.rdata=t}async setL$(e){await this.p.data.set("$H",{_id:"$H"+e})}async setR$(e){await this.rdata.set("$H",JSON.stringify({_id:"$H"+e}))}async unify$H(){const e=Math.random().toString(36).substring(2);await this.setL$(e),await this.setR$(e)}sync(){return this.p.syncInProgress||this.p.db.deferredDeletes.length+this.p.db.deferredWrites.length?new Promise((e=>{setTimeout((()=>e(this.sync())),0)})):new Promise(((e,t)=>{this.p.syncInProgress=!0,this._sync().then((t=>{e(t)})).catch(t).finally((()=>{this.p.syncInProgress=!1}))}))}async decide(e,t,r){const s=e.split("_")[0],i=e.split("_")[1],n=Number(i.substring(2)),o=r.findIndex((e=>e.startsWith(s+"_")));if(o>-1){const s=r[o].split("_")[1];n>Number(s.substring(2))&&(r.splice(o,1),t.push(e))}else t.push(e)}UCV(e){try{e.$$indexCreated?(this.p.db.indexes[e.$$indexCreated.fieldName]=new S(e.$$indexCreated),this.p.db.indexes[e.$$indexCreated.fieldName].insert(this.p.db.getAllData()),delete this.p.db.indexes[e.$$indexCreated.fieldName]):((e=d(e,this.p._model))._id=r(),this.p.db.addToIndexes(e),this.p.db.removeFromIndexes(e))}catch(t){return e.$$indexCreated?(delete this.p.db.indexes[e.$$indexCreated.fieldName],{type:"index",fieldName:e.$$indexCreated.fieldName,sparse:!!e.$$indexCreated.sparse}):{type:"doc",prop:t.prop,value:t.key}}return!1}async _sync(e=!1){const t=await this.rdata.get("$H")||"0",r=JSON.stringify(await this.p.data.get("$H")||0);if(!e&&(r===t||"0"===r&&(t||"").indexOf("10009")>-1))return{sent:0,received:0,diff:-1};const s=(await this.rdata.keys()).sort(T),i=(await this.p.data.keys()).sort(T);s.splice(s.indexOf("$H"),1),i.splice(i.indexOf("$H"),1);const a=[],h=[],l=s.length;let c=0;const d=i.length;let u=0;for(;c<l||u<d;){let e=s[c],t=i[u];e!==t?u===d||T(t,e)>0?(c++,await this.decide(e,a,h)):(u++,await this.decide(t,h,a)):(c++,u++)}if(0===a.length&&0===h.length)return await this.setL$(t.replace(/.*\$H(.*)"}/,"$1")),{sent:0,received:0,diff:0};const f=[],p=a.length?(await this.rdata.getBulk(a)).map((e=>o(this.p.decode(e||"{}")))):[],y=[];for(let e=0;e<a.length;e++){const t=a[e],r=this.UCV(p[e]);if(r&&"doc"===r.type){const e=r.prop;await this.p.data.set(i.find((t=>t.startsWith(e+"_")))||"",{_id:e,$$indexCreated:{fieldName:e,unique:!1,sparse:this.p.db.indexes[e].sparse}})}else r&&"index"===r.type&&(p[e]={$$indexCreated:{fieldName:r.fieldName,unique:!1,sparse:r.sparse},_id:r.fieldName});const s=t.split("_")[0]+"_",n=i.find((e=>e.startsWith(s)))||"";n&&f.push(n),y.push([t,p[e]])}await this.p.data.delBulk(f),await this.p.data.setBulk(y);const w=[],g=h.length?await this.p.data.getBulk(h):[],b=[];for(let e=0;e<h.length;e++){const t=h[e],r=t.split("_")[0]+"_",i=s.find((e=>e.startsWith(r)))||"";i&&w.push(i),b.push([t,g[e]?this.p.encode(n(g[e])):""])}await this.rdata.delBulk(w),await this.rdata.setBulk(b),await this.p.db.loadDatabase();try{this.p.db.live.update()}catch(e){console.error("XWebDB: Could not do live updates due to an error:",e)}return await this.unify$H(),{sent:h.length,received:a.length,diff:1}}}class R{constructor(e){if(this.ref="",this.syncInterval=0,this.syncInProgress=!1,this.corruptAlertThreshold=.1,this.encode=e=>e,this.decode=e=>e,this.stripDefaults=!1,this._model=N,this.shouldEncode=!1,this._model=e.model||this._model,this.db=e.db,this.ref=this.db.ref,this.data=new M(this.ref),this.stripDefaults=e.stripDefaults||!1,this.RSA=e.syncToRemote,this.syncInterval=e.syncInterval||0,this.RSA){const e=this.RSA(this.ref);this.sync=new P(this,e)}if(this.RSA&&this.syncInterval&&setInterval((async()=>{if(!this.syncInProgress){let e;this.syncInProgress=!0;try{await this.sync._sync()}catch(t){e=t}if(this.syncInProgress=!1,e)throw new Error(e)}}),this.syncInterval),this.corruptAlertThreshold=void 0!==e.corruptAlertThreshold?e.corruptAlertThreshold:.1,e.encode&&!e.decode)throw new Error("XWebDB: encode hook defined but decode hook undefined, cautiously refusing to start Datastore to prevent data loss");if(!e.encode&&e.decode)throw new Error("XWebDB: decode hook defined but encode hook undefined, cautiously refusing to start Datastore to prevent data loss");this.encode=e.encode||this.encode,this.decode=e.decode||this.decode;let t=r();if(this.decode(this.encode(t))!==t)throw new Error("XWebDB: encode is not the reverse of decode, cautiously refusing to start data store to prevent data loss");this.shouldEncode=!!e.encode&&!!e.decode}async writeNewIndex(e){return await this.writeData(e.map((e=>[e.$$indexCreated.fieldName,{_id:e.$$indexCreated.fieldName,...e}])))}async writeNewData(e){e=o(n({t:e})).t;for(let t=0;t<e.length;t++){let r=e[t];r._stripDefaults&&(e[t]=r._stripDefaults())}return await this.writeData(e.map((e=>[e._id,e])))}async loadDatabase(){this.db.q.pause(),this.db.resetIndexes(!0);let e=0,t=0;const r=[],s=await this.readData();for(let i=0;i<s.length;i++){t++;const n=s[i];null!==n?n.$$indexCreated?this.db.indexes[n.$$indexCreated.fieldName]=new S({fieldName:n.$$indexCreated.fieldName,unique:n.$$indexCreated.unique,sparse:n.$$indexCreated.sparse}):r.push(this._model.new(n)):e++}for(let e=0;e<r.length;e++){const t=r[e];this.db.addToIndexes(t)}if(t>0&&e/t>this.corruptAlertThreshold)throw new Error(`XWebDB: More than ${Math.floor(100*this.corruptAlertThreshold)}% of the data file is corrupt, the wrong decode hook might have been used. Cautiously refusing to start Datastore to prevent dataloss`);return this.db.q.start(),!0}async readData(){let e=await this.data.documents(),t=[];for(let r=0;r<e.length;r++){let s=e[r];"object"==typeof s&&null!==s?s._id&&s._id.startsWith("$H")||s.$$deleted||void 0===s._id&&void 0===s.$$indexCreated||(s._encoded&&(s=o(this.decode(s._encoded))),t.push(s)):t.push(null)}return t}async deleteData(e){if(!this.RSA)return await this.data.delBulk(e),e;const t=[],r=[];for(let s=0;s<e.length;s++){const i=e[s],n=await this.data.byID(i)||"",o=Math.random().toString(36).substring(2,4)+Date.now(),a=i+"_"+o;t.push(n.toString()),r.push([a,{_id:i,_rev:o,$$deleted:!0}])}return await this.data.delBulk(t),await this.data.setBulk(r),this.sync&&await this.sync.setL$("updated"),e}async writeData(e){if(!this.RSA)return this.shouldEncode&&(e=e.map((e=>[e[0],{_id:e[1]._id,_encoded:this.encode(n(e[1]))}]))),await this.data.setBulk(e),e.map((e=>e[0]));const t=[],r=[];for(let s=0;s<e.length;s++){const i=e[s],o=await this.data.byID(i[0])||"",a=Math.random().toString(36).substring(2,4)+Date.now(),h=i[0]+"_"+a;i[1]._rev=a,t.push(o.toString()),this.shouldEncode&&(i[1]={_encoded:this.encode(n(i[1])),_id:i[1]._id,_rev:i[1]._rev}),r.push([h,i[1]])}return await this.data.delBulk(t),await this.data.setBulk(r),this.sync&&await this.sync.setL$("updated"),e.map((e=>e[0]))}async deleteEverything(){await this.data.clear()}}class K{constructor(e=1){this._queue=[],this._pause=!1,this._ongoingCount=0,this._concurrency=1,this._resolveEmpty=()=>Promise.resolve(),this._concurrency=e}pause(){this._pause=!0}start(){this._pause=!1,this._next()}add(e){return new Promise(((t,r)=>{const s=async()=>{this._ongoingCount++;try{const r=await Promise.resolve().then(e);return this._ongoingCount--,this._next(),t(r),r}catch(e){return this._ongoingCount--,this._next(),r(e),null}};this._ongoingCount<this._concurrency&&!this._pause?s():this._queue.push(s)}))}get waitingCount(){return this._queue.length}get ongoingCount(){return this._ongoingCount}_next(){if(!(this._ongoingCount>=this._concurrency||this._pause))if(this._queue.length>0){const e=this._queue.shift();e&&e()}else this._resolveEmpty()}}function J(e){return s(JSON.stringify(e))}class H{constructor(e){this.queries=[],this.db=e}addLive(e){return e.id=r(),this.queries.push(e),e.id}async update(){for(let e=0;e<this.queries.length;e++){const t=this.queries[e];this.db.cache.evict();const r=await this.db.find(t.query);if(J(r)===J(t.observable.observable))continue;let s=await t.observable.unobserve(t.toDBObserver);t.observable.observable.splice(0),t.observable.observable.push(...r),s.length&&t.observable.observe(t.toDBObserver)}}kill(e){const t=this.queries.findIndex((t=>t.id===e));t>-1&&this.queries.splice(t,1)}}class L{constructor(e=1e3){this.cached=new Map,this.prospected={},this.limit=e}toKey(e){return s(JSON.stringify(e))}get(e){let t=this.toKey(e),r=this.cached.get(t);return r?(this.prospected[t]++,r):void 0}storeOrProspect(e,t){let r=this.toKey(e);if(!this.cached.has(r))if(this.prospected[r]){if(this.prospected[r]++,this.cached.set(r,t),this.cached.size>this.limit){let e={usage:1/0,key:0};for(const t of this.cached.keys()){if(2===this.prospected[t]&&t!==r){this.cached.delete(t),e.key=0;break}this.prospected[t]<e.usage&&(e.usage=this.prospected[t],e.key=t)}0!==e.key&&this.cached.delete(e.key)}}else this.prospected[r]=1}evict(e){e?this.cached.delete(this.toKey(e)):this.cached.clear()}}class U{constructor(e){this.ref="db",this.timestampData=!1,this.live=new H(this),this.q=new K(1),this.indexes={_id:new S({fieldName:"_id",unique:!0})},this.initIndexes=[],this.defer=!1,this.deferredWrites=[],this.deferredDeletes=[],this.model=e.model||N,e.ref&&(this.ref=e.ref),this.cache=new L(e.cacheLimit),this.persistence=new R({db:this,model:e.model,encode:e.encode,decode:e.decode,corruptAlertThreshold:e.corruptAlertThreshold||0,syncToRemote:e.syncToRemote,syncInterval:e.syncInterval,stripDefaults:e.stripDefaults}),this.initIndexes=e.indexes||[],this.timestampData=!!e.timestampData,"number"!=typeof e.defer||isNaN(e.defer)||(this.defer=!0,setInterval((async()=>{this.persistence.syncInProgress||this._processDeferred()}),e.defer))}async _processDeferred(){if(this.deferredDeletes.length)try{const e=await this.persistence.deleteData(this.deferredDeletes);this.deferredDeletes=this.deferredDeletes.filter((t=>-1===e.indexOf(t)))}catch(e){console.error("XWebDB: processing deferred deletes error",e),await this.loadDatabase()}if(this.deferredWrites.length)try{const e=await this.persistence.writeNewData(this.deferredWrites);this.deferredWrites=this.deferredWrites.filter((t=>-1===e.indexOf(t._id||"")))}catch(e){console.error("XWebDB: processing deferred writes error",e),await this.loadDatabase()}}async loadDatabase(){const e=await this.persistence.loadDatabase();for(let e=0;e<this.initIndexes.length;e++){const t=this.initIndexes[e];this.indexes[t]||await this.ensureIndex({fieldName:t})}return this.cache.evict(),e}getAllData(){return this.indexes._id.dict.all}resetIndexes(e=!1){Object.keys(this.indexes).forEach((t=>{if(e&&"_id"!==t)return delete this.indexes[t];this.indexes[t].reset()}))}async ensureIndex(e){if(!(e=e||{}).fieldName){let e=new Error("XWebDB: Cannot create an index without a fieldName");throw e.missingFieldName=!0,e}if(this.indexes[e.fieldName]&&this.indexes[e.fieldName].unique===e.unique)return{affectedIndex:e.fieldName};this.indexes[e.fieldName]=new S(e);try{this.indexes[e.fieldName].insert(this.getAllData())}catch(t){throw delete this.indexes[e.fieldName],t}return await this.persistence.writeNewIndex([{$$indexCreated:e}]),{affectedIndex:e.fieldName}}async removeIndex(e){return delete this.indexes[e],await this.persistence.deleteData([e]),{affectedIndex:e}}addToIndexes(e){let t,r=-1;const s=Object.keys(this.indexes);for(let i=0;i<s.length;i++)try{this.indexes[s[i]].insert(e)}catch(e){r=i,t=e;break}if(t){for(let t=0;t<r;t++)this.indexes[s[t]].remove(e);throw t}}removeFromIndexes(e){Object.keys(this.indexes).forEach((t=>{this.indexes[t].remove(e)}))}updateIndexes(e,t){let r,s=-1;const i=Object.keys(this.indexes);for(let n=0;n<i.length;n++)try{this.indexes[i[n]].update(e,t)}catch(e){s=n,r=e;break}if(r){for(let r=0;r<s;r++)this.indexes[i[r]].revertUpdate(e,t);throw r}}fromDict(e){let t=JSON.parse(JSON.stringify(e)),r=Object.entries(t);r.length&&"$"!==r[0][0][0]&&(t={$noTL:[t]});for(let[e,r]of Object.entries(t))if("$noTL"===e||"$and"===e)for(let e=0;e<r.length;e++){const t=r[e];for(let[e,r]of Object.entries(t)){let t=this.indexes[e];if(!t)continue;r&&0!==Object.keys(r).length&&"$"===Object.keys(r)[0][0]||(r={$eq:r});let s=Object.entries(r);for(let[e,i]of s){if("$not"===e&&null!==i&&"object"==typeof i&&Object.keys(i)&&(i.$eq&&(e="$ne")&&(i=i.$eq),i.$ne&&(e="$eq")&&(i=i.$ne),i.$in&&(e="$nin")&&(i=i.$in),i.$nin&&(e="$in")&&(i=i.$nin),i.$gt&&(e="$lte")&&(i=i.$gt)&&(r.$lte=i),i.$lte&&(e="$gt")&&(i=i.$lte)&&(r.$gt=i),i.$lt&&(e="$gte")&&(i=i.$lt)&&(r.$gte=i),i.$gte&&(e="$lt")&&(i=i.$gte)&&(r.$lt=i)),"$eq"===e)return t.dict.get(i);if("$in"===e)return t.dict.$in(i);if(!(r.$gt||r.$lt||r.$gte||r.lte)){if("$ne"===e)return t.dict.$ne(i);if("$nin"===e)return t.dict.$nin(i)}}if(r.$gt||r.$lt||r.$gte||r.lte)return t.dict.betweenBounds(r.$gt||r.$gte,!!r.$gte,r.$lt||r.$lte,!!r.$lte)}}return null}getCandidates(e){return this.fromDict(e)||this.getAllData()}async insert(e){let t,r=Array.isArray(e)?e:[e],s=[],i=-1;for(let e=0;e<r.length;e++){if(s[e]=d(r[e],this.model),void 0===s[e]._id&&(s[e]._id=this.createNewId()),this.timestampData){let t=new Date;void 0===s[e].createdAt&&(s[e].createdAt=t),void 0===s[e].updatedAt&&(s[e].updatedAt=t)}h(s[e]);try{this.addToIndexes(s[e])}catch(r){t=r,i=e;break}}if(t){for(let e=0;e<i;e++)this.removeFromIndexes(s[e]);throw t}this.cache.evict();try{this.live.update()}catch(e){console.error("XWebDB: Could not do live updates due to an error:",e)}return this.defer?this.deferredWrites.push(...s):await this.persistence.writeNewData(s),{docs:d(s,this.model),number:s.length}}createNewId(){let e=r();return this.indexes._id.dict.has(e)&&(e=this.createNewId()),e}async count(e){const t=new W(this,e);return(await t.exec()).length}async find(e){const t=new W(this,e);return await t.exec()}cursor(e){return new W(this,e)}async _update(e,t,r){let s=void 0!==r.multi&&r.multi,i=void 0!==r.upsert&&r.upsert;const n=new W(this,e);n.limit(1);const o=n.__exec_unsafe();if(o.length>0){let r=0;const i=this.getCandidates(e),n=[];for(let o=0;o<i.length;o++)if((s||0===r)&&_(i[o],e)){r++;let e=i[o].createdAt,s=j(i[o],t,this.model);e&&(s.createdAt=e),!this.timestampData||void 0!==t.updatedAt||t.$set&&void 0!==t.$set.updatedAt||(s.updatedAt=new Date),n.push({oldDoc:i[o],newDoc:s})}this.updateIndexes(n),this.cache.evict();try{this.live.update()}catch(e){console.error("XWebDB: Could not do live updates due to an error:",e)}const o=n.map((e=>e.newDoc));return this.defer?this.deferredWrites.push(...o):await this.persistence.writeNewData(o),{number:o.length,docs:o.map((e=>d(e,this.model))),upsert:!1}}if(0===o.length&&i){if(!t.$setOnInsert)throw new Error("XWebDB: $setOnInsert modifier is required when upserting");let e=d(t.$setOnInsert,this.model,!0);return{...await this.insert(e),upsert:!0}}return{number:0,docs:[],upsert:!1}}async update(e,t,r){return await this.q.add((()=>this._update(e,t,r)))}async _remove(e,t){let r=0;const s=[],i=[];let n=!!t&&!!t.multi;this.getCandidates(e).forEach((t=>{_(t,e)&&(n||0===r)&&(r++,i.push(d(t,this.model)),s.push({$$deleted:!0,_id:t._id}),this.removeFromIndexes(t))})),this.cache.evict();try{this.live.update()}catch(e){console.error("XWebDB: Could not do live updates due to an error:",e)}let o=s.map((e=>e._id||""));return this.defer?this.deferredDeletes.push(...o):await this.persistence.deleteData(o),{number:r,docs:i}}async remove(e,t){return this.q.add((()=>this._remove(e,t)))}}const z="insert",F="update",V="delete",Y=Symbol.for("object-observer-meta-key-0");function Q(e){return e.parent?Q(e.parent):e}function G(e){return JSON.parse(JSON.stringify({tmp:e})).tmp}function Z(e,t,r){const s={};s[Y]=t;for(const i in e)s[i]=ie(e[i],i,t,r);return s}function ee(e,t,r){let s=e.length;const i=new Array(s);i[Y]=t;for(let n=0;n<s;n++)i[n]=ie(e[n],n,t,r);return i}function te(e,t){try{e(t)}catch(r){console.error(`XWebDB: Failed to notify listener ${e} with ${t}`,r)}}function re(){const e=this.batches;this.batches=[];for(const[t,r]of e)te(t,r)}function se(e,t){let r=e;const s=t.length;do{let e=r.observers,i=e.length;for(;i--;){let s=e[i];if(t.length){let e;0===r.batches.length&&queueMicrotask(re.bind(r));for(const t of r.batches)if(t[0]===s){e=t;break}e||(e=[s,[]],r.batches.push(e)),Array.prototype.push.apply(e[1],t)}}const n=r.parent;if(n){for(let e=0;e<s;e++){const s=t[e];t[e]=new oe(s.type,[r.ownKey,...s.path],s.value,s.oldValue,s.object,G(Q(r).proxy))}r=n}else r=null}while(r)}function ie(e,t,r,s){return void 0!==s&&s.has(e)?null:"object"!=typeof e||null===e?e:Array.isArray(e)?new le({target:e,ownKey:t,parent:r,visited:s}).proxy:e instanceof Date?e:new he({target:e,ownKey:t,parent:r,visited:s}).proxy}const ne={pop:function(){const e=this[Y],t=e.target,r=t.length-1;let s=t.pop();if(s&&"object"==typeof s){const e=s[Y];e&&(s=e.detach())}return se(e,[new oe(V,[r],void 0,s,this,G(this))]),s},push:function(){const e=this[Y],t=e.target,r=arguments.length,s=new Array(r),i=t.length;for(let t=0;t<r;t++)s[t]=ie(arguments[t],i+t,e);const n=Reflect.apply(t.push,t,s),o=[];for(let e=i,r=t.length;e<r;e++)o[e-i]=new oe(z,[e],t[e],void 0,this,G(this));return se(e,o),n},shift:function(){const e=this[Y],t=e.target;let r,s,i,n,o;for(r=t.shift(),r&&"object"==typeof r&&(o=r[Y],o&&(r=o.detach())),s=0,i=t.length;s<i;s++)n=t[s],n&&"object"==typeof n&&(o=n[Y],o&&(o.ownKey=s));return se(e,[new oe(V,[0],void 0,r,this,G(this))]),r},unshift:function(){const e=this[Y],t=e.target,r=arguments.length,s=new Array(r);for(let t=0;t<r;t++)s[t]=ie(arguments[t],t,e);const i=Reflect.apply(t.unshift,t,s);for(let e,r=0,s=t.length;r<s;r++)if(e=t[r],e&&"object"==typeof e){const t=e[Y];t&&(t.ownKey=r)}const n=s.length,o=new Array(n);for(let e=0;e<n;e++)o[e]=new oe(z,[e],t[e],void 0,this,G(this));return se(e,o),i},reverse:function(){const e=this[Y],t=e.target;let r,s,i;for(t.reverse(),r=0,s=t.length;r<s;r++)if(i=t[r],i&&"object"==typeof i){const e=i[Y];e&&(e.ownKey=r)}return se(e,[new oe("reverse",[],void 0,void 0,this,G(this))]),this},sort:function(e){const t=this[Y],r=t.target;let s,i,n;for(r.sort(e),s=0,i=r.length;s<i;s++)if(n=r[s],n&&"object"==typeof n){const e=n[Y];e&&(e.ownKey=s)}return se(t,[new oe("shuffle",[],void 0,void 0,this,G(this))]),this},fill:function(e,t,r){const s=this[Y],i=s.target,n=[],o=i.length,a=i.slice(0);if(t=void 0===t?0:t<0?Math.max(o+t,0):Math.min(t,o),r=void 0===r?o:r<0?Math.max(o+r,0):Math.min(r,o),t<o&&r>t){let o;i.fill(e,t,r);for(let e,h,l=t;l<r;l++)e=i[l],i[l]=ie(e,l,s),l in a?(h=a[l],h&&"object"==typeof h&&(o=h[Y],o&&(h=o.detach())),n.push(new oe(F,[l],i[l],h,this,G(this)))):n.push(new oe(z,[l],i[l],void 0,this,G(this)));se(s,n)}return this},copyWithin:function(e,t,r){const s=this[Y],i=s.target,n=i.length;e=e<0?Math.max(n+e,0):e,t=void 0===t?0:t<0?Math.max(n+t,0):Math.min(t,n),r=void 0===r?n:r<0?Math.max(n+r,0):Math.min(r,n);const o=Math.min(r-t,n-e);if(e<n&&e!==t&&o>0){const n=i.slice(0),a=[];i.copyWithin(e,t,r);for(let t,r,h,l=e;l<e+o;l++)t=i[l],t&&"object"==typeof t&&(t=ie(t,l,s),i[l]=t),r=n[l],r&&"object"==typeof r&&(h=r[Y],h&&(r=h.detach())),"object"!=typeof t&&t===r||a.push(new oe(F,[l],t,r,this,G(this)));se(s,a)}return this},splice:function(){const e=this[Y],t=e.target,r=arguments.length,s=new Array(r),i=t.length;for(let t=0;t<r;t++)s[t]=ie(arguments[t],t,e);const n=0===r?0:s[0]<0?i+s[0]:s[0],o=r<2?i-n:s[1],a=Math.max(r-2,0),h=Reflect.apply(t.splice,t,s),l=t.length;let c,d,u,f;for(let e,r=0;r<l;r++)e=t[r],e&&"object"==typeof e&&(c=e[Y],c&&(c.ownKey=r));for(d=0,u=h.length;d<u;d++)f=h[d],f&&"object"==typeof f&&(c=f[Y],c&&(h[d]=c.detach()));const p=[];let y;for(y=0;y<o;y++)y<a?p.push(new oe(F,[n+y],t[n+y],h[y],this,G(this))):p.push(new oe(V,[n+y],void 0,h[y],this,G(this)));for(;y<a;y++)p.push(new oe(z,[n+y],t[n+y],void 0,this,G(this)));return se(e,p),h}};class oe{constructor(e,t,r,s,i,n){this.type=e,this.path=t,this.value=G(r),this.oldValue=G(s),this.object=i,this.snapshot=n}}class ae{constructor(e,t){this.observers=[],this.batches=[];const{target:r,parent:s,ownKey:i,visited:n=new Set}=e;s&&void 0!==i?(this.parent=s,this.ownKey=i):(this.parent=null,this.ownKey=""),n.add(r);const o=t(r,this,n);n.delete(r),this.revocable=Proxy.revocable(o,this),this.proxy=this.revocable.proxy,this.target=o,this.batches=[]}detach(){return this.parent=null,this.target}set(e,t,r){let s=e[t];if(r!==s){const i=ie(r,t,this);if(e[t]=i,s&&"object"==typeof s){const e=s[Y];e&&(s=e.detach())}se(this,void 0===s?[new oe(z,[t],i,void 0,this.proxy,G(this.proxy))]:[new oe(F,[t],i,s,this.proxy,G(this.proxy))])}return!0}deleteProperty(e,t){let r=e[t];if(delete e[t],r&&"object"==typeof r){const e=r[Y];e&&(r=e.detach())}return se(this,[new oe(V,[t],void 0,r,this.proxy,G(this.proxy))]),!0}}class he extends ae{constructor(e){super(e,Z)}}class le extends ae{constructor(e){super(e,ee)}get(e,t){return ne[t]||e[t]}}function ce(e){const t=de(e)?e:new le({target:e,ownKey:"",parent:null}).proxy;async function r(e){return e?Array.isArray(e)?await ue(t,e):await ue(t,[e]):await ue(t)}function s(e){!function(e,t){const r=e[Y].observers;r.some((e=>e===t))||r.push(t)}(t,e)}return{observe:s,unobserve:r,silently:async function(e){const i=await r();await e(t),i.forEach((e=>s(e)))},observable:t}}function de(e){return!(!e||!e[Y])}async function ue(e,t){e instanceof Promise&&(e=await Promise.resolve(e));const r=e[Y].observers;if(!r.length)return[];if(!t)return r.splice(0);let s=[];for(let e=0;e<t.length;e++){const i=t[e],n=r.indexOf(i);n>-1&&s.push(r.splice(n,1)[0])}return s}var fe=Object.freeze({__proto__:null,observable:ce,isObservable:de,Change:oe});class pe{constructor(e){this.subjects=[],this.subjects=e}removeUnusedID(e){return e.map((e=>(void 0===e._id&&delete e._id,e)))}$match(e){return new pe(this.subjects.filter((t=>_(t,e))))}$group({_id:e,reducer:t}){const r={};return this.subjects.forEach((t=>{const s=JSON.stringify({tmp:t[e]});r[s]||(r[s]=[]),r[s].push(t)})),new pe(Object.values(r).map(t))}$limit(e){return new pe(this.subjects.slice(0,e))}$skip(e){return new pe(this.subjects.slice(e))}$addFields(e){return new pe(this.subjects.map((t=>({...t,...e(t)}))))}$sort(e){return new pe(O(this.subjects.slice(0),e))}$project(e){return new pe(this.removeUnusedID(I(this.subjects,e)))}$unwind(e){const t=[];for(let r=0;r<this.subjects.length;r++){const s=this.subjects[r],i=s[e];if(Array.isArray(i))for(const r of i){const i={...s,[e]:r};t.push(i)}else t.push(s)}return new pe(t)}toArray(){return this.subjects}}let ye=k;const we={observable:fe,Cursor:W,customUtils:i,Datastore:U,Index:S,modelling:E,Q:K,Persistence:R,Dictionary:q,Cache:L,Aggregate:pe};e.Database=class{constructor(e){this.create=this.insert,this.find=this.read,this.number=this.count,this.remove=this.delete,this.ensureIndex=this.createIndex,this.model=e.model||N,this.ref=e.ref,this._datastore=new U({ref:this.ref,model:this.model,indexes:e.indexes,encode:e.encode,decode:e.decode,corruptAlertThreshold:e.corruptAlertThreshold,timestampData:e.timestampData,syncToRemote:e.sync?e.sync.syncToRemote:void 0,syncInterval:e.sync?e.sync.syncInterval:void 0,defer:e.deferPersistence,stripDefaults:e.stripDefaults||!1,cacheLimit:e.cacheLimit}),this.loaded=this._datastore.loadDatabase()}async insert(e){await this.loaded;return await this._datastore.insert(e)}async live(e={},{skip:t=0,limit:r=0,project:s={},sort:i={},toDB:n=!0,fromDB:o=!0}={}){await this.loaded;const a=ce(await this.read(...arguments));let h=()=>{},l="";return n&&(h=e=>{let t={};for(let r=0;r<e.length;r++){const s=e[r];if(0!==s.path.length&&"shuffle"!==s.type&&"reverse"!==s.type)if(1===s.path.length&&"update"===s.type){let e=s.snapshot[s.path[0]],r=s.oldValue._id;t[r]=()=>this.update({_id:r},{$set:e})}else if(s.path.length>1||"update"===s.type){let e=s.snapshot[s.path[0]],r=e._id;t[r]=()=>this.upsert({_id:r},{$set:e,$setOnInsert:e})}else if("delete"===s.type){let e=s.oldValue._id;t[e]=()=>this.delete({_id:e})}else if("insert"===s.type){let e=s.value;t[e._id]=()=>this.insert(e)}}const r=Object.values(t).map((e=>e()));Promise.all(r).catch((e=>{this._datastore.live.update(),console.error("XWebDB: Reflecting observable changes to database couldn't complete due to an error:",e)}))},a.observe(h)),o&&(l=this._datastore.live.addLive({query:e,toDBObserver:h,observable:a})),{...a,kill:async e=>{"toDB"!==e&&e||await a.unobserve(h),"fromDB"!==e&&e||this._datastore.live.kill(l)}}}async aggregate(e={}){await this.loaded;const t=await this.read(...arguments);return new pe(t)}async read(e={},{skip:t=0,limit:r=0,project:s={},sort:i={}}={}){await this.loaded,e=f(e),i=f(i),s=f(s);const n=this._datastore.cursor(e);return i&&n.sort(i),t&&n.skip(t),r&&n.limit(r),s&&n.project(s),await n.exec()}async update(e,t,r=!1){await this.loaded,e=f(e||{});for(let e=0;e<ye.length;e++){const r=ye[e];t[r]&&(t[r]=f(t[r]||{}))}return await this._datastore.update(e,t,{multi:r,upsert:!1})}async upsert(e,t,r=!1){await this.loaded,e=f(e||{});for(let e=0;e<ye.length;e++){const r=ye[e];t[r]&&(t[r]=f(t[r]))}return await this._datastore.update(e,t,{multi:r,upsert:!0})}async count(e={}){return await this.loaded,e=f(e||{}),await this._datastore.count(e)}async delete(e,t=!1){await this.loaded,e=f(e||{});return await this._datastore.remove(e,{multi:t||!1})}async createIndex(e){return await this.loaded,await this._datastore.ensureIndex(e)}async removeIndex(e){return await this.loaded,await this._datastore.removeIndex(e)}async reload(){let e=this._datastore.loadDatabase();return this.loaded=e,e}async sync(){if(await this.loaded,!this._datastore.persistence.sync)throw new Error("XWebDB: Can not perform sync operation unless provided with remote DB adapter");return await this._datastore.persistence.sync.sync()}async forceSync(){if(!this._datastore.persistence.sync)throw new Error("XWebDB: Can not perform sync operation unless provided with remote DB adapter");return await this._datastore.persistence.sync._sync(!0)}get syncInProgress(){return this._datastore.persistence.syncInProgress}},e.Doc=N,e.SubDoc=class extends B{},e._internal=we,e.mapSubModel=function(e,t){return{_$SHOULD_MAP$_:!0,def:t,ctr:e}},Object.defineProperty(e,"__esModule",{value:!0})}));